{"meta":{"title":"Mingguk","subtitle":null,"description":null,"author":"minkuk Seo","url":"http://mingguk.github.io","root":"/"},"pages":[],"posts":[{"title":"asynchronous in JS","slug":"asynchronous","date":"2019-05-03T20:03:31.000Z","updated":"2019-05-04T06:55:10.099Z","comments":true,"path":"2019/05/04/asynchronous/","link":"","permalink":"http://mingguk.github.io/2019/05/04/asynchronous/","excerpt":"","text":"Asynchrounous in javascript동기식? 비동기식?자바스크립트는 싱글쓰레드 환경 내 동기식 처리(synchronous)(하나하나씩 작업 수행, 한 작업이 끝나기 전까지 다른작업 수행 안함) 을 기본으로한다. 콜스택 내에서 함수가 실행중인 경우 해당 함수 실행종료까지 다른 함수를 실행할 수 없는 (Blocking) 상태가 되는 것. 만약 모든 코드를 동기식으로만 작성 한다면 한 작업이 끝나기 전까지 다른 어떠한 작업도 할 수가 없고 대기해야되기 때문에 사용자 경험 측면에서 최악, 1~2초만 버벅거려도 해당 사이트를 꺼버리고 싶은 충동이 드는 요즘이라.. 이러한 문제를 해결하기 위해 비동기식 처리 (Asynchronous)를 한다. 비동기식은 다른 작업이 끝날때까지 무한 대기가 아니라, 지정한 작업은 백그라운드에 처리를 위임하고, 동시에 다른 작업을 수행하게 중단 없이 (Non-blocking) 작업을 수행하는 것이다. (javascript 에서는 이런류의 API들을 제공하여 비동기식 처리를 지원한다) 비동기식 처리 Process ( 자바스크립트 엔진은 코드를 한줄씩 순차적으로 수행함, 싱글쓰레드 환경 ) 각 함수들은 execution stack에 추가, 삭제 되며 작업을 수행한다. 이 때 비동기식코드는 timer를 달고 background로 위임된다. 그 동안 다른 작업들은 막힘없이(Non-blocking) 순차적으로 실행 됨. 타이머가 끝난 call-back() 들은 message queue로 이동, 대기 Event loop 는 execution stack 과 message que를 감시, execution stack 이 빌때마다 callback() 을 push 해서 실행시킨다. 동기식 12345678910111213const second() = () =&gt; &#123; console.log(\"second\");&#125;const first = () =&gt; &#123; console.log('first'); second(); console.log(\"finished!\");&#125;first();// first// second// finished! 순으로 순차적으로 실행됨 비동기식 123456//image loadingconst image = document.querySelector(\".img\").src;processLargeImage(image, () =&gt; &#123; // 오래걸리는 이미지 처리 callback()으로 비동기식 처리 //.....&#125;) 비동기 처리 방법들1. ES5 : Callback()콜백함수(call-back)는 지금이 아닌 나중에 실행되는 함수다. 보통 함수의 인자 로 전달되어 특정 시점에 실행되도록 의도된 함수로서, 비동기적 처리가 요구되는 이벤트처리, 네트워크 응답, 파일입출입, 시간지연등에 전통적으로 사용되는 방식이다. 복잡한 작업수행을 위해서 비동기처리가 중첩되다보면은 소위 콜백지옥(Callback hell) 에 빠질 수 있고 에러발생 파악이 어려워 가독성 저하, 유지보수 어려움 등을 겪을 수 있다 123456789101112131415161718function getRecipe() &#123; setTimeout(() =&gt; &#123; const recipeID = [1,2,3,4]; console.log(recipeID); setTimeout((id) =&gt; &#123; const recipe = &#123;title: 'pizza', publisher: 'Min'&#125;; console.log(`$&#123;id&#125;: $&#123;recipe.title&#125;`); setTimeout(publisher =&gt; &#123; const recipe2 = &#123;title: 'pasta', publisher: 'Han'&#125;; console.log(recipe); //.... 이런식으로 계속 이전 비동기 처리 결과를 인자로 받아 Chaining 가능.. //.... 콜백함수가 너무 중첩되다보면 콜백지옥에 빠져 코드파악, 유지보수 어려워 지는 단점 존재..! &#125;,1500, recipe.publisher); &#125;, 1000, recipeID[2]); &#125;, 2000);&#125;getRecipe(); 2. ES6: Promise콜백의 단점을 해결하기 위해 ES6부터 공식 지원되는 방식이다. Promise의 핵심은 상태(State)를 분류해서 각 상태에 맞게 비동기 처리를 수행할 수 있다는 점이다. 1.이벤트 발생 전 (pending) 2.이벤트 발생 (settle / resolved) 3-1. 이벤트 성공 (Fulfilled) 3-2. 이벤트 실패 (Rejected) 이벤트 결과 처리 (Consume) - then() / catch() 이벤트 성공여부 상태에 따라 각각 핸들링 할 수 있기 때문에 간결한 코드 작성, 에러처리가 수월하다. 123456789101112131415161718192021222324const getIDs =new Promise((resolve, reject) =&gt; &#123; // 이벤트 성공시 resolve 호출, 실패시 reject setTimeout(() =&gt; &#123; resolve([1,2,3,4]); &#125;,1500);&#125;);const gerRecipe = recID =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const recipe = &#123;title: 'Pizza', publisher: 'John'&#125;; resolve('$&#123;ID&#125;: $&#123;recipe.title&#125;'); &#125;,1500, recID)&#125;getIDs //Consume .then(IDs =&gt; &#123; // 이벤트 성공 시 then() 으로 결과처리 console.log(IDs); // [1,2,3,4]; return getRecipe(IDs[2]); // 이 함수는 또 promise 객체를 리턴 할 것이므로&#125;) .then(recipe =&gt; &#123; // 리턴된 promise에 또 then()을 걸어 결과처리가능 (chaining!) console.log(recipe);&#125;); .cathch(error =&gt; &#123; // 이벤트 실패 시 catch() 으로 에러처리 console.log(error);&#125;) 3. ES8: Async, Awaitasync,await 또한 promise 의 단점들을 보완하고자 탄생했다. promise 보다 훨씬 짧고 간결한 코드작성 가능, try/ catch 동일 방식으로 동기/비동기 에러 모두 처리가능, 디버깅 용이하다. 특히 백그라운드에서 비동기식으로 작동함에도 코드를 마치 동기식처럼 작성할 수 있어서 가독성 , 코드간결성 면에서는 탁월하다. async 키워드 함수는 background 에서 실행되어 promise를 리턴하고, async 안의 await키워드 function은 그 promise 가 fulfilled 될때 까지 대기 했다가 promise를 consume (처리) 한다. 12345async function getRecipesAW() &#123; // promise 를 리턴 하는 함수 const IDs = await getIDs; // await키워드는 promise 가 fulfilled 될때까지 코드실행x, 대기 const recipe = await getRecipe(IDs[2]);&#125;getRecipesAW(); async 함수는 백그라운드에서 실행, 이벤트가 성공되기 전에까지 대기 하기 때문에 1234567891011121314async function getRecipeAW() &#123; const IDs = await getIDs; const recipe = await getRecipe(IDs[2]); return recipe;&#125;//아래 코드는 작동x, getRecipeAW()가 완료되기 전 console.log(rec)가 미리 실행되 버리기 때문const rec = getRecipeAW();console.log(rec); //Promise &#123;&lt;pending&gt;&#125; //따라서 리턴되는 promise를 .then() 을 통해 완료 후 처리 하도록 해주면 정상작동 됨getRecipeAw().then(recipe =&gt; &#123; console.log(recipe); // &#123;title: 'Pizza, publisher: 'Min'&#125;;&#125;) 4. fetch()기존 XHR 객체 비해 좀 더 간결하게 코드작성 가능, 최신 API로 promise 객체를 결과로 리턴하고, Header, Request, Response 객체도 직접 핸들링 할 수 있는 특징이 있음 1234567891011121314151617181920212223242526272829// 무료 날씨 api metaweather.com/api 예제//Promise + fetchfetch// AJAX 를 처리해서 promise 객체 리턴('https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/2487956/').then(result =&gt; &#123; // default 방식: GET return result.json(); //json객체로 변환&#125;) .then(data =&gt; &#123; //다시 한번 .then() 으로 결과 가져오기 const today = data.consolidated_weather[0]; console.log(`$&#123;data.title&#125; : $&#123;today.min_temp&#125; and $&#123;today.max_temp&#125; deg`)&#125;) .catch(error =&gt; &#123; console.log(error);&#125;)//San Francisco 12.5 and 24 deg// 옵션으로 통신 방식 지정 가능fetch(\"url\", method: \"POST\"&#125;) .then(result =&gt; &#123; return result.json(); &#125;) .then ( data =&gt; &#123; console.log(data.title); &#125;) .cathch(err =&gt; &#123; console.log(err); &#125; 12345678// Async Await + fetchasync function getWeatherAW(woeid) &#123; const result = await fetch('https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/2487956/'); const data = await result.json(); consloe.log(data);&#125;getWeatherAW(44418); Related Postshttps://jeong-pro.tistory.com/128 https://www.udemy.com/the-complete-javascript-course/ https://www.zerocho.com/category/HTML&amp;DOM/post/595b4bc97cafe885540c0c1c","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"asynchrounous","slug":"asynchrounous","permalink":"http://mingguk.github.io/tags/asynchrounous/"},{"name":"비동기","slug":"비동기","permalink":"http://mingguk.github.io/tags/비동기/"}]},{"title":"til 5월 1주차","slug":"19-5-1","date":"2019-05-03T11:38:32.000Z","updated":"2019-05-03T02:51:36.866Z","comments":true,"path":"2019/05/03/19-5-1/","link":"","permalink":"http://mingguk.github.io/2019/05/03/19-5-1/","excerpt":"","text":"todo ES6 주요내용 정리하기 part 1, part2 / 정리해서 블로깅 Udemy bootstrap 완강, 정리 Learn by doing 시작 (유튭 brad js 1 / css 1 개씩 매일 만들기!) 블로그 개편, TWIL (This Week I Learned…) 추가 , 코드블록 수정…(왜 안되냐고..진짜!!) React, node js 학습플랜, 만들기 연습 플랜 짜기 19/05/03 뭐임마 어쩌라고 comment리액트 노드 넘어가기 전 마지막 주 ES6 정리도 필요하고 블로그도 개편해야되고 바쁜 한주였다.. 집중력 키우기, 뽀모도로 활용!","categories":[{"name":"post","slug":"post","permalink":"http://mingguk.github.io/categories/post/"},{"name":"twil","slug":"post/twil","permalink":"http://mingguk.github.io/categories/post/twil/"}],"tags":[{"name":"twil","slug":"twil","permalink":"http://mingguk.github.io/tags/twil/"}]},{"title":"ES6 Part-2","slug":"ES6-2","date":"2019-05-03T11:23:14.000Z","updated":"2019-05-03T23:56:23.212Z","comments":true,"path":"2019/05/03/ES6-2/","link":"","permalink":"http://mingguk.github.io/2019/05/03/ES6-2/","excerpt":"","text":"목차 Class map, set modules (추가중) 1. Class자바스크립트는 프로토타입 기반 객체지향을 구현할 수 있다. ES6 에서 class를 활용 해서 좀 더 간결하게 구현 할 수 있다 123456789101112//ES5 (생성자 함수 + 프로토타입 메소드 사용 객체지향 구현)var Person = function(name, yearOfBirth, job) &#123; this.name = name; this.yearOfBirth = yearOfBirth; this.job = job; Person.prototype.calcAge() = function() &#123; var age = new Date().getFullYear() - this.yearOfBirth; console.log(age); &#125; &#125; console.log(min) // min = &#123;name: Min , yearOfBirth: 1990 , job: developer&#125; 12345678910111213141516171819202122232425//ES6 (Class 를 통한 객체지향 구현 간소화지원 , 재사용성 up!)class Person &#123; constructor(name, yearOfBirth, job) &#123; // 생성자 함수 지원 this.name = name; this.yearOfBirth = yearOfBirth; this.job = job; &#125; caclAge() &#123; // 간소화 된 Method 추가 const age = new Date().getFullYear() - this.yearOfBirth; console.log(age); &#125; //static method , 인스턴스에 상속x class로만 사용가능 static greet() &#123; // 인스턴스 생성 불필요, 전역에서 쓰이는 범용 유틸리티 함수 생성 시 주로 이용된다. console.log(\"Hi there!\"); &#125;&#125;// new 연산자로 인스턴스 생성 시 호출 되는건 Person 의 constructor 임const min = new Person(\"Min\", 1990, \"developer\"); console.log(min) // min = &#123;name: Min , yearOfBirth: 1990 , job: developer&#125;Person.greeting() // Hi there!//class 정의는 결국 =&gt; 함수 정의 =&gt; 함수 = 객체 =&gt; 객체 내 greet메소드를 추가한 격 상속, Subclass 12345678910111213141516171819202122232425262728//ES5var Person = function(name, yearOfBirth, job) &#123; this.name = name; this.yearOfBirth = yearOfBirth; this.job = job; Person.prototype.calcAge() = function() &#123; var age = new Date().getFullYear - this.yearOfBirth; console.log(age); &#125; &#125;var Developer = function(name, yearOfBirth, job, portfolio) &#123; Person.call(this, name, yearOfBirth, job) // 부모 갹체 person으로 부터 상속 this.portfolio = portfolio;&#125;Developer.prototype.makePortfolio() = function() &#123; this.portfolio = true; console.log(this.portfolio);&#125;//Object.create() 는 객체의 prototype을 임의지정할 수 있음Developer.prototype = Object.create(Person.prototype) //prototype 연결(=상속)var junior = new Developer(\"Min\", 1990, 'developer', true);junior.calcAge(); // 26, Person 의 calcAge() 상속받아 차용junior.makeProtfolio(); // true 1234567891011121314151617181920212223242526272829//ES6class Person &#123; constructor(name, yearOfBirth, job) &#123; // 생성자 함수 지원 this.name = name; this.yearOfBirth = yearOfBirth; this.job = job; &#125; caclAge() &#123; // 간소화 된 Method 추가 const age = new Date().getFullYear() - this.yearOfBirth; console.log(age); &#125;&#125;class Developer extends Person &#123; constructor(name, yearOfBirth, job, portfolio) &#123; super(name, yearOfBirth, job); // super 키워드로 부모 객체로 부터 상속 this.portfolio = portfolio; &#125; makePortfolio() &#123; this.portfolio = true; console.log(this.portfolio); &#125;&#125;const junior = new Developer('Min', 1990, \"developer\", false);junior.calcAge(); // 26junior.makePortfolio(); // true 2. map,setmap map 은 object 와 유사하지만 몇가지 주요한 차이점 존재 key 로 어떠한 type도 지정 가능하다 (object는 String만 가능) 삽입된 순서로 key 가 정렬된다. size 로 map 의 요소의 수를 셀 수 있다. iteratorable, 순회 할 수 있다. 12345678910111213141516171819202122232425262728293031let question = new Map();//요소 추가, set()question.set('what', '지금 배우고 있는 자바스크립트 버전의 공식명은?')question.set(1, 'ES5');question.set(2, 'ES6');question.set(3, 'ES1997');question.set('correct', '3');question.set(true, 'Correct answer!');question.set(false, 'Wrong!');//요소 불러오기, get()console.log (question.get('what')); // 지금 배우고 있는 자바스크립트 버전의 공식명은?console.log(question.size) // 6//삭제, delete() 확인, has()if (question.has(4)) &#123; question.delete(4);&#125;// iterable, use loop!question,forEach((value, key) =&gt; &#123; console.log (`$&#123;key&#125; =&gt; $&#123;value&#125;`) // key 1,2,3,4 =&gt; ES5,ES6,ES1997...&#125;)//entries(), 모든 [key,value] 형태 iterator객체를 반환함for (let [key, value] of question.entries()) &#123; if (type of(key) === 'number') &#123; //map은 모든 타입 key 값 지정 가능 활용! console.log(`answer: $&#123;value&#125;`); &#125;&#125; set set은 중복값을 허용하지 않기 때문에, 유니크한 값을 찾거나, 중복값을 체크할 때 유용하다 12345678910111213141516171819202122232425let set = new Set();//중복 불가set.add(1);set.add(2);set.add(1);console.log(set); // set &#123; 1, 2&#125; , 이미 존재하는 값은 추가x//set 반복, forEachset.forEach(function(val) =&gt; &#123; console.log(val); // 1, 2)&#125;;//has(), 값이 존재하는지 확인console.log(set.has(\"3\"))// false//delte() 삭제 / clear() 모두삭제// spread operator 로 array &lt;-&gt; set 전환const items = new Set();items.add('가방');items.add('신발');items.add('핸드폰');let item2 = [...items] weakmap, weakset 생략 ( key가 객체, 가비지컬렉션 허용) 3. Modules외부에서(다른파일) 에서 코드를 불러오는 방식, 12345678910111213//index.js , 메인파일//단일 코드 불러오기import string from './models/Search'; //string은 임의명 ,from 은 상대경로 지정//복수 코드들 불러오기import &#123; add, multifly, ID&#125; from './function';//import &#123; add as a, multifly as b, ID&#125; from './function'; // as, 별명으로 사용가능console.log(add(1,2)); // 3console.log(multifly(5,ID)); // 5 //import * as Search from './function' // 모두 불러오기Search.add() //이런식으로 사용가능 12//Search.js , 내보낼 파일1 (단수)export default 'search.js'; // 하나의 객체만 내보낼때, 불러온 쪽에서 임의이름으로 사용가능 1234//functions.js , 내보낼 파일2 (복수) // 내보 낼 객체 앞에 export 키워드 붙여줄 것export const add = (a,b) =&gt; a + b;export const multiply = (a,b) =&gt; a * b;export const ID = 1; ###4. (추가중) Related Posts","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://mingguk.github.io/tags/ES6/"}]},{"title":"ES6 Part-1","slug":"ES6","date":"2019-05-01T17:26:57.000Z","updated":"2019-05-03T23:55:31.915Z","comments":true,"path":"2019/05/02/ES6/","link":"","permalink":"http://mingguk.github.io/2019/05/02/ES6/","excerpt":"","text":"ES6 정리 (간단예제 위주)목차 let &amp; index Arrow function String Array Object Destructuring 1. let &amp; constES5 - var 가 function scope 를 가졌던 것에 반해 ES6 의 const 와 let 은 Block scope를 가진다 1234567//ES5function fn() = &#123; if(true) &#123; var name = \"Kim\"; // var , 가변적 &#125; console.log(name);&#125; 12345678910111213//ES6function fn2() &#123; if (true) &#123; const lastname = \"Kim\"; // const , 불변 //lastname = \"Park\" // (Error) const는 상수취급 let age = 23; // let , 가변 &#125; console.log(lastname, age); &#125;fn(); // Kimfn2(); // (Error) lastname, let are not defined 단, const 객체, 배열은 변경 가능 12345678const obj = &#123; name: \"a\", age: 25&#125;obj.name = \"b\";console.log(obj.name); // b Closure 관련 문제 123456789var list = document.querySelector(\".list\");for(var i=0; i&lt;list.length(5); i++) &#123; list[i].addEventListener(\"click\", function() &#123; console.log(i + 번째 항목); &#125;);&#125;// 전부 4번쨰 항목 출력// i를 let i = 0; 으로 수정하면 간단히 해결가능 2. Arrow Function 코드 축약 가능 1234567891011121314//ES5var arr = [1,2,3,4,5];arr.map(function(num) =&gt; &#123; return num * 2;&#125;)//ES6let arr = [1,2,3,4,5];arr.map( (num) =&gt; &#123; return num * 2;&#125;)//한 번 더 축약 가능arr.map( num =&gt; num * 2); Arrow function 사용 시 this context arrow function가 선언된 기준으로 해당 Arrow function 을 감싸고 있는 블록에 this가 바인딩 된다. 1234567891011121314151617181920//ES5var object = &#123;run() &#123; setTimeout(function() &#123; console.log(this); &#125;,2000); &#125;&#125; object.run(); // window //window 아닌 현재 객체에 this를 바인딩 하기 위해서 .bind(this) 주로 사용//ES6const object = &#123;run() &#123; setTimeout(() =&gt; &#123; console.log(this); &#125;,2000); &#125;&#125; object.run(); // object 객체 메소드 형태로 사용하지 말 것 123456789let obj = &#123; a: 1, b: () =&gt; console.log(this.a); c: function() &#123; console.log(this.a) &#125;&#125;obj.b(); // undefined 메소드로 사용 시 this 가 window에 바인딩 됨.obj.c(); // 1 3. StringNew String methods 12345678910111213141516//startsWith, endsWithlet str = \"hello world\";console.log(str.starsWith(\"hello)); // trueconsole.log(star.endsWith(\"ld\")); // true//includeslet str2 = 'hi hello 안녕';console.log(str2.includes(\"안녕\")) // true//repeatlet str3 = \"a\";console.log( str3.repeat(3)) // aaa Template literals 불편한 문자열 처리 방식이 간편하게 바뀌었다 DOM string 처리 시 유용 내에서 ${변수명} 으로 변수 인식이 가능함 123456789//ES5var a = \"hi\";var name = \"Min\";console.log( a + \" \" + \"my name is \" + name); // hi my name is Minconst a = ‘hi';const name = “Min”;console.log (`$&#123;a&#125; my name is $&#123;name&#125;`); // hi my name is Min 4. Arrayfor of 123456789101112var numbers = [1,2,3,4,5];var str = \"hello\"for (let num of numbers) &#123; console.log(num);&#125;// 1,2,3,4,5for (let c of str ) &#123; console.log(c);&#125;// h,e,l,l,o Array.from() 1234567891011121314//ES5function addMark() &#123; var newData = []; //for(var i =0; o&lt;arguments.length; i++) &#123; //newData.push(arguments[i] + \"!\"); // &#125; // 혹은 Array.protorype.slice.call() 식으로 차용해야 했음var newData = arguments.map(function(val) &#123;//(error) arguments 는 유사배열, return val + \"!\"; // Array의 Methods 사용불가&#125;) console.log(newData);&#125;addMark(1,2,3,4,5); 1234567891011121314//ES6function addMark() &#123; let newArr = Array.from(arguments); // 유사배열 arguments -&gt; 배열로 변환 let newData = newArr.map(function(val) &#123; return val + \"!\"; &#125;); console.log(newData);&#125;addMark(1,2,3); // [\"1!\",\"2!\",\"3!\"]//DOM 관련 NodeList 조작 시 유용하게 쓰임let list = document.querySelectorAll('list-item');let itmes = Array.from(list); // items = [item~]; 배열처럼 조작 가능하게 해줌! Spread operator 펼침 연산자, 인자로 넘겨주거나, 객체 리터럴, 배열 리터럴 혹은 문자열 에 편하게 사용 할 수 있다 12345678910111213141516171819202122//인자로 넘길 떄function fn(a,b,c) &#123; console.log(a + b + c);&#125;let arr = [1,2,3];fn(...arr) // 6// 배열리터럴let arr = [\"a\",\"b\",\"c\"];let newArr = [1,2, ...arr, 3, 4]; // [1,2,\"a\",\"b\",\"c\",4]// 배열 붙여넣기//ES5var arr1 = [1,2,3];var arr2 = [4,5,6];arr1 = arr1.concat(arr2);//ES6arr1 = [...arr1, ...arr2]; 5. ObjectObject literal 확장 12345678910111213141516171819202122// 표현 간소화//ES5function person(name, age) &#123; return &#123; name: name, age: age, sayName: function() &#123; console.log(this.name) &#125; &#125;;&#125;//ES6function person(name, age) &#123; return &#123; name, age, sayName() &#123; console.log(this.name); &#125; &#125;;&#125; Object.assign() 12345678910//ES5 object.create()const greeting = &#123; sayHi: function() &#123; console.log(\"안녕하세요, \" + this.name + \"님\"); &#125;cc&#125;const greet = Object.create(greeting);greet.name = \"Min\"; // 이처럼 클래스 속성들을 일일히 추가해줘야 되는 단점 존재console.log(greet.sayHi()); // 안녕하세요 Min님 12345678910111213141516171819//object.assign()Object.assign(target, ...sources)sources 의 속성들이 모두 target 에 복사 됨let obj = &#123;a = 1, b = 2, c =3&#125;;let newObj = Object.assign(&#123;&#125; , obj);console.log(newObj) // &#123;a=1, b=2, c=3&#125;// target이 빈객체 &#123;&#125; 아닌 존재하는 객체 일 때let obj = a = 1, b = 2, c = 3;let obj2 = &#123;d = 4&#125;let newObj = Object.assign(obj2, obj);console.log(newObj) // &#123;a=1,b=2,c=3,d=4&#125;console.log(obj2) // &#123;a=1,b=2,c=3,d=4&#125; //하지만 target으로 지정했던 객체도 변형 됨//Object.assing()로 새로운 병합된 객체를 리턴 받고자 한다면 target에 빈 객체 &#123;&#125; 를 지정 할 것 6. Destructuring배열요소나 객체의 속성을 리터럴 같이 사용해서 좀 더 간결한 방식으로 변수에 할당하는 것 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Array//ES5 (새 변수에 할당 할 때 배열 요소의 인덱스가 필요)var arr = [1,2,3];var newArr = [];var newVar = arr[2];newArr.push[arr[0],arr[1],arr[2]];//ES6 (인덱스 불필요, 배열 요소들을 변수처럼 자유롭게 재할당 가능)let [newNum] = data;console.log(newNum); // 1,2,3let a,b,c;[a,b,c] = ['hi', 'hellow' '안녕']console.log(a,b,c,) // hi, hellow, 안녕// 일부 요소, 특정 요소만 할당도 가능let data = [1,2,3,4,5];let [a, ,b] = data;console.log(a,b) //1,3// 기본값 지정 let &#123;a = 'a, b = 'b'&#125; = &#123;a: '아' &#125;;console.log(b); // b//rest patternlet [a, ...b] = data;console.log(a, b) // a = 1 / b= 2,3,4,5//Obejct//ES5var obj = &#123; name: 'Min', age: 32&#125;var person = &#123;&#125;;person.name = 'Min';person.age = 32;consoloe.log(person.name, person.age) // Min, 32//ES6let obj = &#123; name: 'Min', age: 32&#125;let &#123;name, age&#125; = objconsole.log(name, age) = min,32let &#123;a:myName, b:myAge&#125; = obj;console.log(a,myName,b.myAge) // Min, 32 destructuring 활용 1234567891011121314151617181920212223//JSON 파싱const news = [ &#123; 'title' : \"SBS, 'thumnail' : \"https://www.sbs.co.kr/news/5.png\", 'content' : \"주커버그, 코딩이 제일 쉬웠다고 밝혀 충격!\" &#125;, &#123; 'title' : \"MBC, 'thumnail' : \"https://www.MBC.co.kr/news/1.png\", 'content' : \"학생들 주커버그 의견 반박, \"장난하나...\"\" &#125;,]let [ ,mbc] = news; // MBC 기사만 추출 let &#123;title, thumnail&#125; = mbc; // mbc 기사의 제목, 섬네일만 추출// 위의 두과정을 한번에 중첩으로 추출 가능let [ , &#123;title, ,content&#125;] = news;console.log(content)// 학생들 주커버그 의견 반박, \"장난하나...\" References윤지수님 인프런 ES6 강좌 JSDEV 자바크스립트 개발자포럼 ES6 글 Related PostsES6 part-2","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://mingguk.github.io/tags/ES6/"}]},{"title":"How CSS Works","slug":"css","date":"2019-03-20T20:17:05.000Z","updated":"2019-03-21T07:28:37.031Z","comments":true,"path":"2019/03/21/css/","link":"","permalink":"http://mingguk.github.io/2019/03/21/css/","excerpt":"","text":"Related PostsHow to bulid a good website 반응형 웹 다양한 기기들의 다른 스크린 사이즈에 각각 최적화 된 화면을 보여주는 것 유지보수, 확장 가능한 코드 깔끔하고 누구나 알아보기 쉽게 잘 설계, 조직화 된 코드를 짜야된다. 웹 어플리케이션이 성장함에 따라 자연스럽게 코드 양이 늘어나거나 문제 발생 시 잘 설계된 코드는 시간과 비용을 현저히 줄여준다. 성능 웹사이트 성능 저하를 피하기 위해 가능한 적은 요청과, 코드, 이미지를 효율적으로 조정하는게 필요하다. What happens to css when we load up a webpage? 브라우저가 HTML 파일 로드 HTML 의 코드를 한줄 한줄 해독 해독 과정에서 코드를 DOM 구조로 빌드 CSS 파일 또한 로드 CSS 파일을 한줄씩 해독 5-1. CSS Cascade (충돌하는 css 선언 조정) 5-2. CSS 최종 속성값 결정 CSSOM 빌드 (Like DOM) DOM + CSSOM -&gt; 최종 tree 구조 빌드 VIsual Formatting Model Website rendering (실제 브라우저 통해 보여지는 단계) 단계별 정리 How CSS is parsed? Cascading and Specificity CASCADE? 특정 요소에 한 가지 이상의 속성 값이 지정됐을 때 최종적으로 어떤 속성값을 적용할 것인지 조정하고 결정하는 단계 (Author 지정 값 / css, style 에 유저 직접 지정 값 / 브라우저 자체 기본속성값 등.. 중에서 어느 속성을 최종 적용 할 것인가!? 의 문제) Importance —&gt; specificity —&gt; source order 순으로 비교, 요소에 적용 될 속성값 최종 결정 1) importance (!important 키워드 포함된 blue 로 최종 결정!) 2) specificity ( 어느 것이 더 세부적, 구체적인가?) 3) source Order (importance, specificity 가 같다면 가장 나중에 쓰여진 속성 적용)** 참고사항 Value Processing CSS 적용 할 최종 속성값을 산출하는 과정 Declared value (선언된 값) —&gt; Cascaded value( 속성 값 두가지 이상 일 때, 어느걸 적용 할까~? —&gt; Specified value (속성 값 하나 일 때) —&gt; Computed value (상대적인 값들 -&gt; 절대값(px로 변환 됨) —&gt; Used value (레이아웃 따라 값 산출 부모, % 라던지..) —&gt; Actual value (브라우저 나 디바이스 기본설정 따라 최종 값 산출) relative —&gt; absolute value (px) font-size : 부모의 font-size 기준 length: 부모의 width 기준 Font-based : em(font) : 부모 / em(length)(현재 요소 크기) / rem (root 기준) Viewport-based : vh(height) / vw(width) 3.inheritance 요소에 지정된 css value가 없다면 부모에게서 상속 될 수 있는 요소가 있는지 확인 하고 부모의 computed value를 상속받아 적용한다. How CSS render a website? (Visual Formatting Model) 웹사이트 레이아웃은 각각의 컴포넌트(내용)들을 담은 박스들의 합이다. 이 박스들을 구상한 레이아웃에 따라 조화롭게 배치해야한다. 1) Box Model 2) Box Types 3) Positioning Schemes 4) Stacking Contexts 중첩, 레이어 개념 어느것을 최상위로 보여 줄 것인지 How to build good CSS architecture? 효율적으로 CSS 를 3단계로 나눠서 구현하는 방식 1) 설계 컴포넌트 단위 베이스, 어디서나 재사용 가능하고 독립적으로 작성 할 것 2) 구현 (의미있는 네이밍, 조직화 된 classes, ids) BEM block 홀로 의미를 갖는 컴포넌트 단위 block—element 특정 블록 내에서만 의미 갖는 컴포넌트 modifier (기본형에서 변형된, 한번만 사용되는) 3) 폴더별 관리 (Sass)","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"html css","slug":"Front/html-css","permalink":"http://mingguk.github.io/categories/Front/html-css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://mingguk.github.io/tags/css/"}]},{"title":"til 3월 1,2주차","slug":"twil 19-03-1","date":"2019-02-25T17:10:18.000Z","updated":"2019-05-03T02:42:24.581Z","comments":true,"path":"2019/02/26/twil 19-03-1/","link":"","permalink":"http://mingguk.github.io/2019/02/26/twil 19-03-1/","excerpt":"","text":"19/03/02 todo web dev Restful 까지 수강 code signal 3 문제 풀이 Build real js app section 7 1/2 파트 수강 jobjobjs 수강신청, 준비tw til 포스팅 comment주말을 쿨하게 놀았다. 아직 정신을 못차렸나보다. web dev course 풀스택 체험 하려는데 집중도가 점점 떨어진다. 월말까지 일단 최대한 시도 해보고.. 남은 서버파트는 나중에 완강 고려해봐야겠다, front 쪽과 특히 자바스크립트 심화공부를 먼저 더 집중하는게 맞는거 같아서 커리큘럼을 조금 수정하고 있다. 3원화 시켜 메인 공부 (자바스크립트) / 서브1 ( 알고리즘(문제해결)) / 서브2 (html,css(front , etc)) 식으로 매일 나눠서 진행하는 걸로 할 생각이다. 공부, 수강 끝나고 만족할 만한 결과물이 나온다면 그 때 서버쪽 연동, 풀스택에 도전하는게 맞는거 같다. 알고리즘 연습사이트 인데, 기록, 결과물 경쟁시스템, 챌린지등 컨텐츠랑 ux 모두 맘에드는 사이트를 발견해서 공유한다 [코드시그널](https://codesignal.com/) 19/03/06 todo udemy modern html&amp;css 섹션 5~7 수강 responsive webpage 완성 toddler project codestates SA-2 완성, 풀리퀘 til 블로깅 commentudemy web dev full-stack 수강 하고 웹개발 전체 큰 그림 파악 완료 front-end 쪽에 집중해서 배우고 빠르게 프론트엔드 쪽 포트폴리오 및 블로깅 진행해야겠다 css media query 첨써봤는데 정말 편리하다. 더 이상 float 에서 고통받지 않아도 되.. 반응형웹 기초들 따라 만들어 보고 있는데 꽤 흥미가 간다. 완성 후 혼자 다시 복기 철저히 해서 체화 필요 brad trasversy 의 유데미 강의들을 통째 결제 했는데.. 역시 믿고보는 빵형.. 간만에 알고리즘 문제들 풀었더니 역시나 감이 좀 떨어진거같다. 매일 지속적으로 조금씩 병행해야겠다 javascript reduce, map , filter, forEach 등 매번 쓸 때마다 헷갈리는거 같다. 조만간한 한 번 용례랑 쭉 정리해서 포스팅을 하 면서 정리해야겠다. underscore.js 를 제대로 다시 해보는 것도 고려 19/03/08 todo section 7 (flexbox 반응형웹 복기, 직접 만들고 정리) udemy modern html&amp;css section 8,9,10 수강 underbar advanced 전까지 다시 풀기 til 포스팅 주말까지 udemy modern html &amp; css 완강, 정리하기 js 알고리즘 선별, 준비 ( 매일 3문제 / 정리 블로깅 / udemy js algorithms) 담주부터 udemy brad js 코스 brad css 복기 정리 / 2번째 css코스 시작 js algoritms 하루 한강 수강~!? (혹은 다른 것) commentudemy web dev full-stack 수강 하고 웹개발 전체 큰 그림 파악 완료 front-end 쪽에 집중해서 배우고 빠르게 프론트엔드 쪽 포트폴리오 및 블로깅 진행해야겠다 css media query 첨써봤는데 정말 편리하다. 더 이상 float 에서 고통받지 않아도 되.. 반응형웹 기초들 따라 만들어 보고 있는데 꽤 흥미가 간다. 완성 후 혼자 다시 복기 철저히 해서 체화 필요 brad trasversy 의 유데미 강의들을 통째 결제 했는데.. 역시 믿고보는 빵형.. 간만에 알고리즘 문제들 풀었더니 역시나 감이 좀 떨어진거같다. 매일 지속적으로 조금씩 병행해야겠다 javascript reduce, map , filter, forEach 등 매번 쓸 때마다 헷갈리는거 같다. 조만간한 한 번 용례랑 쭉 정리해서 포스팅을 하 면서 정리해야겠다. underscore.js 를 제대로 다시 해보는 것도 고려 Related Posts","categories":[{"name":"post","slug":"post","permalink":"http://mingguk.github.io/categories/post/"},{"name":"twil","slug":"post/twil","permalink":"http://mingguk.github.io/categories/post/twil/"}],"tags":[{"name":"twil","slug":"twil","permalink":"http://mingguk.github.io/tags/twil/"}]},{"title":"backend","slug":"backend","date":"2019-02-20T21:55:28.000Z","updated":"2019-02-20T13:21:51.313Z","comments":true,"path":"2019/02/21/backend/","link":"","permalink":"http://mingguk.github.io/2019/02/21/backend/","excerpt":"","text":"Internet basics ISP에 요청(query) -&gt; DNS 가 IP address 로 변환 -&gt; http 를 통해 가장 빠른 경로로 요청이 해당 IP address 의 서버로 전달 -&gt; 해당 서버가 요청에 해당하는 정보를 DB에서 가져와 응답 -&gt; 요청된 자료 송신 -&gt; 요청자의 브라우저에 의해 데이터가 렌더링 되서 보여짐 Static vs Dynamic같은 요청에 같은 결과를 출력하는 것을 static , 매 요청 시 조건마다 다른 결과를 출력해주는 건 dynamic HTTPRelated Posts","categories":[{"name":"Back","slug":"Back","permalink":"http://mingguk.github.io/categories/Back/"},{"name":"basic","slug":"Back/basic","permalink":"http://mingguk.github.io/categories/Back/basic/"}],"tags":[{"name":"backend","slug":"backend","permalink":"http://mingguk.github.io/tags/backend/"}]},{"title":"twil 2월 2주차","slug":"twil 19-02-1","date":"2019-02-19T15:44:30.000Z","updated":"2019-05-03T02:36:24.438Z","comments":true,"path":"2019/02/20/twil 19-02-1/","link":"","permalink":"http://mingguk.github.io/2019/02/20/twil 19-02-1/","excerpt":"","text":"todo RGB color guessing game 완성 (DOM 연습) source code JQUERY 입문 완강 javascript Todo list 완성하기 hexo 블로그 TIL 포스팅 환경 세팅하기(비디오, 깃헙 연동) Todolist (jQuery) 준비하기 comment일부러 라이브러리 없이 바닐라 자바스크립트로만 공부해오다 드디어 라이브러리에 살짝 발을 담궈봤다 (불편함을 겪어봐야 왜 이게 좋은지, 필요한지 격하게 느낄 수 있다길래..) 되게 많이 편하다. 근데 한편으로 이 기능이 왜 되는지, 안되는지 알 수 없어서 약간 자존심이 상한다는 느낌? 앞으로 일주일간 html,css 를 js 로 조작 연습 위해 toy projects 를 몇개 진행하고, udemy colt steel web bootcamp 마무리를 할 예정이다. 19/02/23 todo Todolist (jQuery) 완성 source code backend basics, command line 완강 node js 기초 완강 server side Frameworks 완강 express, intermidiate express 반강 codestates PRE SA1 제출 c9 개발환경 세팅 til 포스팅 주말(23~24) 할 일 Web dev Data Associations 까지 수강, 정리 블로깅 정리 commentjs 의 hello world, Todo list 를 완성 했다, html / css 와 js 간의 연계에 조금 익숙해 진거 같다. 강의 진도에 목메다 보니 강의만 순차적으로 따라가고 금방금방 넘어가니 돌아서니 남는게 없다, 좀 느리게 가더라도 배운것을 그때그때 작은 기능이라도 직접만들어 보고 경험하는식으로 바꿔야겠다 오늘부터 기초 back end 영역 공부를 시작했다, node js express 를 배웠는데 그동안 몰랐던 웹페이지들 연계, 코딩을 이런식으로 하는구나~ 깨달았다. 주말부터~다음주까지 이 풀스택 기초과정을 끝내고, 전체 돌아가는 그림을 파악한 뒤 다음 커리큘럼을 고민해봐야겠다.","categories":[{"name":"post","slug":"post","permalink":"http://mingguk.github.io/categories/post/"},{"name":"twil","slug":"post/twil","permalink":"http://mingguk.github.io/categories/post/twil/"}],"tags":[{"name":"twil","slug":"twil","permalink":"http://mingguk.github.io/tags/twil/"}]},{"title":"Building objects","slug":"Building-an-object","date":"2019-02-04T18:03:18.000Z","updated":"2019-05-03T07:24:42.305Z","comments":true,"path":"2019/02/05/Building-an-object/","link":"","permalink":"http://mingguk.github.io/2019/02/05/Building-an-object/","excerpt":"","text":"객체를 생성하는 여러가지 방식 중 하나는 new 키워드를 활용한생성자 함수 를 사용하는 방법이 있다. new keyword123456789101112131415// java 같은..function Person() &#123; console.log(this); this.firstname = &apos;John&apos;, this.lastname = &apos;Doe&apos; console.log(&apos;This function is invoked.&apos;);&#125;//new는 특별한 operator 이다var john = new Person(); //생성자 함수//console.log(john);&#123;&#125;This function is invoked.Person &#123;firstname: &apos;John&apos;, lastname: &apos;Doe&apos;&#125; 생성자 함수 (new + function() ) 생성자 함수가 실행되면 아래와 같은 순서로 진행된다. {} 빈 객체 생성 Person() 실행 - execution 생성, this 생성(this 는 생성된 빈 객체 가르킴) Person() 내 로직 따라 빈객체에 firstname, lastname 속성 추가 됨 생성된 객체 Person{firstname: ‘John’, lastname: ‘Doe’} 리턴 따라서 new 키워드와 + 정의된 Person() 를 실행 할 때마다 새로운 객체, Person()의 인스턴스 를 생성한다고 할 수 있다. 123456789101112//필요한 요소를 인자로 받으면 서로 다른 속성 가진 인스턴스 생성 가능function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname;&#125;var john = new person(&apos;John&apos;, &apos;Doe);var jane = new person(&apos;Jane&apos;, &apos;Doe&apos;);console.log(jane);// Person &#123;firstname: &apos;Jane&apos;, lastname: &apos;Doe&apos;&#125; 객체가 생성되면 자동으로 prototype 이라는 속성이 빈 객체 {} 로 추가된다. 생성자함수를 사용 할 때만, prototype 속성이 사용된다. 123456//아래 코드를 추가하면 Person.prototype.getFullName = function() &#123; return this.firstname + &apos; &apos; + this.lastname;&#125;// new Person() 으로 생성된 객체들은 모두 getFullName() 을 속성으로 갖게된다. 그냥 Person() 내에 해당 함수를 추가해주면 되지않나?그렇게 되면 생성된 모든객체에 함수가 중복존재하기 때문에 메모리가 낭비된다. 주의사항 new를 실수로 빼먹으면 Person() 함수는 리턴값이 없기 때문에 undefined error 발생, 이러한 이유로 생성자 함수를 일반 함수와 구분하기 위해 첫글자를 대문자로 생성해주는 컨벤션 존재 built-in functions 각 타입의 기본객체의 prototype 에 속성이나 메소드를 추가하면 생성자함수로 생성한 모든 객체에서 해당 속성, 메소드에 접근할 수 있다. 12345678910111213String.prototype.isLengthGreaterThan = function(limit) &#123; return this.length &gt; limit;&#125;// String 기본객체의 prototype 에 함수 추가 했음으로// 모든 string 에서 해당 함수 호출 가능console.log(&apos;John&apos;.isLengthGreaterThan(3));Number.prototype.isPositive = function() &#123; return this &gt; 0;&#125;var a = new Number(3);a.isPositive(); // true 주의사항 1234567891011121314151617181920212223// 객체타입과 원시타입 간 차이 주의 할 것var a = 3; //primitive typevar b = new Number(3); // Objectvar c = Number(&apos;3&apos;); // 3a == b // true;a === b // false;//Arrays and For invar arr = [&apos;John&apos;, &apos;Jane&apos;, &apos;Jim&apos;];for (var prop in arr) &#123; console.log(prop + &apos;: &apos; + arr[prop]);&#125;// 0: John// 1: Jane// 2: Jim ???//array 도 객체라서 key : value pair 로 묶여버림Array.prototype.myCustomFeature = &apos;cool&apos;; // myCustomFeature : cool// 자바스크립트 배열에서는 array 에서 for..in 쓰지 말 것! 또 다른방식으로 객체를 생성하는 방식을 알아보자 12345678910111213var person = &#123; firstname: &apos;Default&apos;, lastname: &apos;Default&apos;, greet: function() &#123; return &apos;Hi &apos; + this.firstname; &#125;&#125;//prototype 이 생성된 객체 그자체로 설정되는 방식var john = Object.create(person);john.firstname = &apos;John&apos;;john.lastname = &apos;Doe&apos;;console.log(john); Class &amp; ES612345678910111213// prototype 을 설정하는 방식 extendsclass Person extends Human&#123; constructor(firstname, lastname) &#123; //super(firstname, lastname); this.firstname = firstname; this.lastname = lastname; &#125; greet() &#123; return &apos;Hi &apos; + firstname; &#125;&#125;var john = new Person(&apos;John&apos;, &apos;Doe&apos;); Odds and Ends1234567891011121314151617181920212223242526272829// Initializationvar people = [ //object 1 &#123; firstname: &apos;John&apos;, lastname: &apos;Doe&apos; address: [ &apos;111 Main St.&apos;, &apos;222 Third St.&apos; ] &#125;, //object2 &#123; firstname: &apos;Jane&apos;, lastname: &apos;Doe&apos;, address: [ &apos;333 Main St.&apos;, &apos;444 Fifth St.&apos; ], greet: function() &#123; return &apos;Hello!&apos;; &#125; &#125;]console.log(people);// Related PostsjQuery OOP in javascript","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"OOP in javascript","slug":"OOP-in-javascript","date":"2019-02-04T16:31:58.000Z","updated":"2019-05-03T07:02:39.955Z","comments":true,"path":"2019/02/05/OOP-in-javascript/","link":"","permalink":"http://mingguk.github.io/2019/02/05/OOP-in-javascript/","excerpt":"","text":"prototype타 언어의 전통적인 상속은 상속을 구현하기 위해 많은 부수적인 것들을 고려해야 됐다. 반면에 자바스크립트의 상속은 prototypal inheritance로 좀 더 유연하고 직관적이다. 123456789101112131415161718192021222324var person = &#123; firstname: 'Default', lastname: ;Default', getFullName: function() &#123; return this.firstname + ' ' + this.lastname; &#125;&#125;var john = &#123; fristname: 'John', lastname: 'Doe'&#125;//don't do this Ever! demo purposes only!john.__proto__ = person;//john 객체에서 속성이나 메소드 탐색 후 없으면 proto&#123;&#125; 탐색console.log(john.getFullName()); // John Doevar jane = &#123; firstname: 'Jane';&#125;jane.__proto__ = person;console.log(jane.getFullName()); // Jane Default; Everyting is and object1234567var a = &#123;&#125;;var b = function() &#123;&#125;;var c = [];a.__proto__. // Object&#123;&#125; (base object);b.__proto__. // Empty() &#123;&#125; (base function object);c.__proto__. // b 는 빈함수임에도 proto 를 살펴보면 기본 함수 객체의 모든 메소드들에 접근이 가능하다. (빈 배열, 객체도 마찬가지) 우리가 어떤 배열, 객체, 함수를 생성했을 때 따로 명시적으로 메소드를 생성하지 않더라도 자바스크립트 엔진이 프로토타입을 자동으로 기본 객체들에 연결해준다. 이 때문에 기본 객체들에 있는 메소드들을 새로 생성한 객체에서도 자유롭게 사용할 수 있는 것이다. Reflection and Extend 함수정의 때와 다른 인자 개수를 받을 때는 arguments 를 통해 처리할 수 있다. (추후 수정) 1234567891011121314151617181920212223242526272829303132333435var person = &#123; firstname: 'Default', lastname: ;Default', getFullName: function() &#123; return this.firstname + ' ' + this.lastname; &#125;&#125;var john = &#123; fristname: 'John', lastname: 'Doe'&#125;for (var prop in john) &#123; if (john.hasOwnProperty(prop)) &#123; console.log(prop + ': ' + john[prop]) &#125;&#125;// firstname : 'John', lastname : 'Doe'var jane = &#123; address: '111 Main St.'; getFormalFullName: function() &#123; return this.lastname + ', ' + this.firstname; &#125;&#125;var jim = &#123; getFirstName: function() &#123; return firstname; &#125;&#125;// 다른 객체들의 속성들을 다른 객체에게 전달하고 싶다면?_.extend(john, jane, jim ..);// 다른 객체들의 속성,메소드들을 추가한 john 객체가 리턴 됨. Related Posts building an object Functional programming","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"Funtional programming","slug":"Funtional-programming","date":"2019-02-03T16:29:45.000Z","updated":"2019-05-03T07:24:10.782Z","comments":true,"path":"2019/02/04/Funtional-programming/","link":"","permalink":"http://mingguk.github.io/2019/02/04/Funtional-programming/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 비함수형var arr1 = [1,2,3];console.log(arr1);var arr2 = [];for (var i=0; i&lt;arr1.length; i++) &#123; arr2.push(arr[i] * 2);&#125;console.log(arr2);// 함수형//기반 함수 생성function mapForEach(arr, fn) &#123; var newArr = []; for (var i=0; i&lt;arr1.length; i++) &#123; newArr.push( fn(arr[i]) ) &#125;; return newArr;&#125;// 기반함수에다 다른 함수를 인자로 넣어 다양하게 활용 가능var arr2 = mapForEach(arr1, function(item) &#123; return item * 2; &#125;);console.log(arr2);var arr3 = mapForEach(arr1, function(item) &#123; return item &gt; 2;&#125;)// 인자 수가 다른 함수는 어떻게 활용할 수 있을까?var checkPastLimit = function(limiter, item) &#123; return item &gt; limiter;&#125;// bind()로 limiter 인자 기본값 지정해주면 가능var arr4 = marForEach(arr1, checkPastLimit.bind(this, 1));// 매번 bind() 달지않고 싶다면//bind() 포함한 새로운 함수를 만들어서var checkPastLimitSimplified = function(limiter) &#123; return function(limiter, item) &#123; return item &gt; limiter; &#125;.bind(this, limiter);&#125;;var arr5 = mapForEach(arr1, checkPastLimitSimplified(1));console.log(arr5); 함수형 프로그래밍은 1급함수 성질을 활용해서, 각각의 함수를 인자나 리턴으로 또 함수를 전달하도록 해서 보다 단순화되고 효율적인 코드를 작성할 수 있다. 함수형 프로그래밍에 대한 이해도를 좀 더 높히고 싶다면 아래의 라이브러리 함수들을 직접 구현해 보는 것을 추천한다. codestates pre course에서도 비슷한 것을 경험한 적이 있는데, 가장 기본적인 함수들을 재사용 해서 다른 라이브러리 함수 로직을 직접 구현해 보는 연습을 할 수 있다. Underscore.js 도전하기! Related Posts Next call bind apply","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"call&apply&bind","slug":"Call-Bind","date":"2019-02-02T21:24:12.000Z","updated":"2019-05-03T07:24:04.435Z","comments":true,"path":"2019/02/03/Call-Bind/","link":"","permalink":"http://mingguk.github.io/2019/02/03/Call-Bind/","excerpt":"","text":"자바스크립트 함수에는 앞서 언급한 code, name 외에도 call, apply, bind 라는 기본 메소드를 갖고 있다. 이 메소드들은 this 키워드를 조작해주는 역할을 한다. bind()12345678910111213141516171819202122var person = &#123; firstname : 'John', lastname : 'Doe', getFullName: function() &#123; var fullname = this.firstname + ' ' + this.lastname; return fullname; &#125; &#125;var logName = function(lang1, lang2) &#123; console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + lang1 + ' ' +. lange2); console.log('----------');&#125; // .bind(person) 해도 아래와 동일한 결과logName(); // undefined error, 현재 this는 logName//logPersonName 의 this를 person 으로 변경var logPersonName = logName.bind(person);logName(); // this가 person으로 변경, Logged John Doe bind() 는 새로운 함수를 반환하는데 인자로 들어가는 객체를 함수의 this로 바꿔주는 역할을 한다. call(), apply()12345678910111213141516171819202122232425262728293031323334353637383940var person = &#123; firstname : 'John', lastname : 'Doe', getFullName: function() &#123; var fullname = this.firstname + ' ' + this.lastname; return fullname; &#125; &#125;var logName = function(lang1, lang2) &#123; console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + lang1 + ' ' +. lange2); console.log('----------');&#125; var logPErsonName = logName.bind(person);logPersonName('en');logName.call(person, 'en', 'es');console.log('mmmmmmmmmmmmmmm');logName.apply(person, ['en', 'es']);//Logged: John Doe//Arguments: en es//----------------//mmmmmmmmmmmmmmmm//Logged: John Doe//Arguments: en es//----------------//IIFE 로도 가능(function(lang1, lang2) &#123; console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + lang1 + ' ' +. lange2); console.log('----------');&#125;).apply(person, ['en', 'es']);//Logged: John Doe//Arguments: en es//---------------- call() 과 apply() 는 bind와 마찬가지로 this를 변경하고, 인자를 넘기고 함수를 실행까지 한다. 둘의 차이는 인자를 따로 넘기냐, 묶여서 배열로 넘기냐의 차이밖에 없다. Why? When?그럼 언제 이 메소드들을 활용할 수 있을까 123456789101112131415161718192021//1. function borrowingvar person2 = &#123; // getFullName() 없는 객체 생성 firstname : 'John', lastname : 'Doe',&#125;// person 의 getFullName() 빌려 올 수 있다console.log( person.getFullName.apply(person2) );//2. function curryingfunction multiply(a,b) &#123; return a*b;&#125;//인자 기본값을 넣은 새로운 함수 생성 효과var multipleByTwo = multiply.bind(this, 2); console.log(multipleByTwo(4)); // 8var multipleByThree = multiply.bind(this, 3);console.log(multipleByTwo(4)); // 12 Related PostsFunctional programming Closure part2","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"Closure part2","slug":"Closure2","date":"2019-02-02T18:43:06.000Z","updated":"2019-05-03T07:23:50.343Z","comments":true,"path":"2019/02/03/Closure2/","link":"","permalink":"http://mingguk.github.io/2019/02/03/Closure2/","excerpt":"","text":"공장에서 정해진 포멧에 따라 제품들을 생산하는 것처럼 팩토리패턴은 전체 로직을 담은 팩토리함수를 생성, 클로저를 활용해서 반복되는 인자를 기본값으로 하는 함수를 재정의 하고, 호출하는 방식이다. 123456789101112131415161718192021// factory functionfunction makeGreeting(language) &#123; return function(firstname, lastname) &#123; //inside function if (language === 'en') &#123; console.log('Hello ' + firstname + ' ' + lastname); &#125; if (language === 'es') &#123; console.log('Hola ' + firstname + ' ' + lastname); &#125; &#125;&#125;// 매번 호출마다 새로운 execution context 생성var greetEnglish = makeGreeting('en');var greetSpanish = makeGreeting('es');// 직접 language 접근못하지만, 사용하는 함수greetingEnglish('John', 'Doe');greetingSpanish('John', 'Doe'); 코드 실행 시 makeGreeting(‘en’) 을 만나면 execution context 를 생성하고 en을 할당한다. makeGreeting(‘es’) 동일하게 진행되고, 함수실행이 끝나면 language 만 남게된다. 그 다음 greetingEnglish(), greetingSpanish() 가 실행되면 각각의 outer environment 에서 language를 참조 즉, 클로저를 통해 각각의 langauge를 참조하여 각각의 함수를 실행하고 결과를 출력하게 된다. Closure and Callback콜백함수는 다른 함수에 인자로 넘긴 함수로, 다른함수 실행이 끝나면 실행되도록 한 함수이다. 1234567891011121314151617181920212223242526272829function sayHiLater() &#123; //외부변수 greeting 참조, closure var greeting = 'Hi'; setTimeout(function() &#123; console.log(greeting); &#125;, 3000);&#125;sayHiLater();function tellMeWhenDone(callback) &#123; var a = 1000; var b = 2000; callback(); // 인자로 넣은 함수&#125;tellMeWhenDone(function() &#123; console.log(\"I'm done!'); &#125;);tellMeWhenDone(function() &#123; alert(\"I'm done!'); &#125;);tellMeWhenDone(function() &#123; console.log(\"All done'); &#125;); Related PostsCall &amp; Apply &amp;Bind Closure part1","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"Closure part1","slug":"Closure","date":"2019-02-01T00:00:10.000Z","updated":"2019-05-03T07:23:33.600Z","comments":true,"path":"2019/02/01/Closure/","link":"","permalink":"http://mingguk.github.io/2019/02/01/Closure/","excerpt":"","text":"12345678910111213141516//결과로 함수를 리턴 하는 함수function greet(whattosay) &#123; return function(name) &#123; console.log(whattosay + ' ' + name); &#125;&#125;greet('Hi')('Tony');//Hi Tony// greet() 실행이 끝나면 greet()의 execution context 사라짐var sayHi = greet('Hi'); // 그럼에도 불구하고 어떻게 sayHi()가 다시 whattosay를 참조 했을까?sayHi('Tony'); //Hi tony Closure, 클로저 ? greet(‘Hi’) 가 실행되면 execution context를 생성하고, whattosay 변수를 생성한다. greet() 코드 실행이 끝나면 greet() 의 execution context 는 삭제되지만 whattosay 는 메모리에 여전히 남아있다. 그 다음 sayHi(‘Tony’) 가 실행되면 execution context, name 변수 생성하고 다시 한 번 greet() 의 코드를 실행할 것이다. 그러다 console.log(whattosay + ‘ ‘ + name); 코드를 다시 만나면 sayHi(“Tony”)의 execution context 에서 whattosay 변수를 탐색하고, 없다면 스코프체인을 따라 outer environment에서 whattosay를 다시 탐색, 코드를 실행한다. greet() 함수가 종료되었음에도 내부의 function(name) { console.log(whattosay + ‘ ‘ + name) }; 은 여전히 외부의 whattosay에 접근할 수 있는 셈이다. 다시말해, 외부함수가 종료된 뒤에도 내부함수는 여전히 외부함수의 execution context가 사용한 메모리공간에 접근이 가능하다는 것이다. 이러한 특성을 Closure, 클로저라고 한다. 자바스크립트에서는 이 클로저의 특성을 활용한 패턴이 매우 빈번하게 활용되고 있으니 꼭 그 원리를 이해하고 넘어가자. 클로저 예제 아래의 예제를 살펴보자. 1234567891011121314151617181920function buildFunction() &#123; var arr = []; for (var i = 0; i &lt;3; i++) &#123; arr.push( function() &#123; console.log(i); &#125; ) &#125; return arr;&#125;var fs = buildFunction();fs[0]();fs[1]();fs[2]();// 3 3 3 (!?!? 왜때문에?) 코드를 잘 살펴보자 buildFunction() 이 먼저 실행되면 노란색으로 표시한 for문 내부의 로직은 expression 이 아니라 statement기 때문에 실행되진 않고 함수선언 자체가 배열에 각각 삽입 될 것이다. buildFunction() 실행이 끝나면 exectuion context 는 삭제되지만 해당 변수들은 메모리에 남아있다. 이후 fs[0,1,2] 함수가 각각 실행되어 내부로직을 실행할 때 클로저 특성에 따라 arr과 i를 참조하게 된다. fs() 를 호출하는 시점에서 i의 값은 3이기 때문에 3번의 실행 모두 i=3 을 참조 해서 0,1,2 가 아닌 3,3,3을 출력하게 된다. ###만약 0,1,2를 출력하게 하려면? let keyword 12345678910111213141516171819function buildFunction2() &#123; var arr = []; for (var i = 0; i &lt;3; i++) &#123; let j = i; //block 내 한정, 함수 호출마다 다른 i 삽입 arr.push( function() &#123; console.log(j); &#125; ) &#125; return arr;&#125;var fs = buildFunction();fs[0]();fs[1]();fs[2](); IIFE 12345678910111213141516171819202122232425function buildFunction3() &#123; var arr = []; for (var i = 0; i &lt;3; i++) &#123; arr.push( (function(j) &#123; return function() &#123; console.log(j); &#125; &#125;)(i); //IIFE로 각각의 ec 생성, i를 변수j에 저장하면 //내부함수 실행마다 closure로 각각의 //i값 저장한 변수j에 접근가능 =&gt; 0,1,2 ) &#125; return arr;&#125;var fs = buildFunction();fs[0]();fs[1]();fs[2](); 각각의 execution context 를 생성하고 그때마다 i를 따로 저장하면 가능한데 ,execution context를 생성하는 유일한 방법은 함수를 실행하는 것이다.. -&gt; IIFE 활용 Related PostsClosure part2 IIFE","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"IIFE","slug":"IIFE","date":"2019-01-31T19:48:00.000Z","updated":"2019-05-03T07:23:14.002Z","comments":true,"path":"2019/02/01/IIFE/","link":"","permalink":"http://mingguk.github.io/2019/02/01/IIFE/","excerpt":"","text":"12345678910111213141516171819//function statementfunction greet(name) &#123; console.log('Hello ' + name); &#125;greet('John); //Hello John//using a function expression var greetFunc = function(name) &#123; console.log('Hello ' + name);&#125;;greetFunc(); //Hello John//IIFE 함수 생성 후 바로 실행시킴var greetFunc = function(name) &#123; return 'Hello ' + name;&#125;('John');console.log(greeting); // Hello John 1234567891011121314151617181920212223242526273; //vaild'I'm a string' //vaild&#123; name: 'John' &#125; //vaild//그렇다면 함수는?//function statement function(name) &#123; return 'Hello ' + name;&#125;// function 키워드를 보면 statement라고 인식// 함수명을 요구하기에 error 발생!// statement를 괄호()로 묶으면 expression으로 인식// 함수 생성과 호출을 동시에, IIFEvar tom = 'Tom'(function(name) &#123; var greeting = 'Inside IIFE: Hello'; console.log(greeting + ' ' + name); &#125;(tom)); // Inside IIFE: Hello Tom//IIFE 구조(function &#123;...&#125;)(); //괄호 밖(function &#123;...&#125;()); // 괄호 안, 둘 다 가능 Why IIFE ? IIFE 코드가 실행되면 발생하는 일 Global Execution context 생성 IIFE 코드, expression을 만나면 메모리에 () 함수 공간 할당 코드 끝 호출 () 를 만나면 새로운 Execution context 생성 IIFE 내 변수들 메모리에 할당 () , Not to Global Object 12345678//index.html&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=\"greet.js\"&gt;&lt;/script&gt; &lt;script src=\"app.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12//greet.jsvar greeting = 'Hola'; 12345678910//app.js(function(name) &#123; var greeting = 'Hello'; console.log(greeting + ' ' + name);&#125;)('John'); //IIFEconsole.log(greeting);// Hello John// Hola ​ Global 의 greeting 과 IIFE 의 greeting 이 충돌없이 공존 Conclusion IIFE 코드 내 변수들은 전부 IIFE 의 Execution context 내의 variable environment 에 속하기 때문에 전역객체에 영향 안줌, 전역 변수나 다른 execution context 들의 변수들과 충돌 가능성 없음! 이 때문에 대부분의 라이브러리나 프레임워크는 IIFE 형식으로 설계 되어있음 1234567var global = window;(function(global, name) &#123; var greeting = 'Hello'; global.greeting = 'Hello global'; console.log(greeting + ' ' + name);&#125;)(window, 'John'); //IIFE 만약 IIFE 로 글로벌 객체에 영향을 주고 싶다면? IIFE에 글로벌 객체를 인자로 전달해서 조작하면 가능 Related PostsClosure arguments &amp; etc","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weridparts","slug":"weridparts","permalink":"http://mingguk.github.io/tags/weridparts/"}]},{"title":"arguments & etc","slug":"argument","date":"2019-01-31T13:25:15.000Z","updated":"2019-05-03T07:22:50.736Z","comments":true,"path":"2019/01/31/argument/","link":"","permalink":"http://mingguk.github.io/2019/01/31/argument/","excerpt":"","text":"Array as an Object12345678910111213141516171819202122// Dynamic typing 때문에 서로 다른 타입 요소로 가질 수 있음var arr = [ 1, false, &#123; name: 'Tony', address: '111 Main St.' &#125;, function(name) &#123; var greeting = 'Hello '; console.log(greeting + name); &#125;, \"hello\"; ];//객체, 함수도 요소로 받을 수 있어 바로 호출도 가능console.log(arr);arr[3](arr[2].name); // Hello Tony arguments Execution context 가 생성될 때 variable environmnet, this, outer environment 외에 또 하나의 특별한 키워드가 생성 되는데 바로 arguments ,함수들에 넘긴 모든 인자들을 다 담은 객체이다. 12345678910111213141516171819202122function greet (firstname, lastname, language) &#123; // default 값 설정 language = language || 'en'; if (arguments.lenght === 0) &#123; console.log('Missing parameters!'); console.log('--------------'); return; &#125; console.log(firstname); cosole.log(lastname); console.log(language); console.log(arguments) //유사배열,따로 선언안해도 사용가능 console.log('arg 0: ' + arguments[0]) //&#125;greet(); // 3개 다 undefined // 함수 선언 시 설정한 인자들을 다 넘길수 / 일부만 넘길수도 / 안넘길수도 있다greet('John'); // John / undefined / undefinedgreet('John', 'Doe'); // John, Doe, undefinedgreet('John', 'Doe', 'es'); // John, Doe, es 여기서 argumnets 는 유사배열 이다. 유사배열은 [] 숫자 key를 가지고, length 속성을 가지지만 실제배열의 메소드들은 사용할 수 없다. 12345678910111213141516171819//Array.isArray() 로 유사배열여부 판단 가능var arr = [1,2,3];Array.isArray(arr); // true// 배열처럼 index 접근,length 속성 가짐function checkArg() &#123; console.log(arguments); console.log(arguments.length); console.log(arguments[1]);&#125;checkArg(a,b,c); // Arguments [a,b,c ..]// 3// b// call, apply 를 사용 유사배열에 배열의 메소드를 차용할 수 있다. Array.prototype.slice.call(arguments,1,2); Function overloading다른 프로그래밍 언어들은 오버로딩 (같은 이름, 다른타입or 숫자의 인자를 가진 여러개의 함수 생성 가능) 을 지원한다. 자바스크립트는 오버로딩을 지원하진 않지만 1급함수 특성을 활용, 더 유연하게 구현이 가능하다. 123456789101112131415161718192021222324function greet(firstname, lastname, language) &#123; language = language || 'en'; if (language === 'en') &#123; console.log('Hello ' + firstname + ' ' + lastname); &#125; if (language === 'es') &#123; console.log('Hola ' + firstname + ' ' + lastname); &#125;&#125;// 만약 다른 인자를 받는 함수를 만들고 싶다면// 이런식으로 기존 함수를 활용, 오버로딩처럼 구현 가능function greetEnglish(firstname, lastname) &#123; greet(firstname, lastname, 'en');&#125;function greetEnglish(firstname, lastname) &#123; greet(firstname, lastname, 'en');&#125;greet('John', 'Doe', 'en'); // Hello John Doegreet('John', 'Doe', 'es'); // Hola John Doe 세미콜론( ; ) 꼭 입력해야될까?자바스크립트 엔진은 작성한 코드를 한자 한자 syntax parser 를 통해 읽어 코드의 의도를 읽고 문법을 판단해서 코드를 실행시킨다. 이때 자바스크립트 엔진은 세미콜론이 필요하다고 판단되는 위치에 자동으로 추가해준다. 12345678function getPerson() &#123; return //자바스크립트 엔진에 의해 자동으로 ; 추가 됨 &#123; firstname: 'Tony' &#125;&#125;console.log(getPerson()); // undefined 위의 코드 실행 결과를 객체 {firstname: ‘Tony’} 라고 의도했겠지만 실제 결과는 return 뒤에 ; 콜론이 필요하다는 자바스크립트 엔진의 판단으로 인해 빈값이 리턴되어 undefined 이다. 이런 의도치 않은 오류를 방지하기 위해 세미콜론은 명시적으로 입력하는 습관을 가지자. Related PostsIIFE this","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"this","slug":"jsw this","date":"2019-01-31T02:09:19.000Z","updated":"2019-05-03T07:22:29.136Z","comments":true,"path":"2019/01/31/jsw this/","link":"","permalink":"http://mingguk.github.io/2019/01/31/jsw this/","excerpt":"","text":"자바스크립트에서 함수가 실행될 때마다 새로운 Execution context를 생성하고 각 Execution context 는 variable Environmnet, Outer Environment 그리고 this 를 생성한다. this 는 함수의 위치, 호출되는 방식에 따라 특정 객체를 가르키게 된다. 5 cases of this 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1. 전역 호출 시 - 전역객체console.log(this); // Window &#123;...&#125;//2. 함수 내 일반 호출 시 - 전역객체function a() &#123; console.log(this); this.newVariable = 'hello'; //전역객체(Window) 에 새 함수 할당&#125;a(); // window &#123;...&#125;this.newVariable; // hello//3. 메소드(객체 내 함수) 호출 시 - 메소드 포함하는 객체var c = &#123; name: 'The c object', log: function() &#123; this.name = 'Updated c object'; console.log(this); &#125;&#125;//4. new keyword - 인스턴스(new 키워드로 생성한) 객체function person(name) &#123; this.name = name;&#125;var tom = new Person('Tom');console.log(tom.name); // Tomconsole.log(name); // error!//5. .call , .apply - 각 함수 첫번째 인자 객체function speak() &#123; var greeting = 'Hello i'm + this.name;&#125;var person = &#123; name: 'tom', age: 18&#125;;speak.call(person); // tomc.log(); // c, Object &#123; name:'Updated c object', log: function() &#123;console.log(this)&#125;&#125;console.log(newVariable); // helloa(); // Window 주의할 점 (메소드 내부함수에서 this 호출 시 123456789101112131415161718192021222324var c = &#123; name: 'The C object'; log: function() &#123; this.name = 'Updated c object'; console.log(this); // 메소드의 내부함수의 this는 또 전역을 가르키는 오류 있음 var setname = function(newName) &#123; this.name = newName; &#125; setName('Updated again! The c object'); console.log(this);ß &#125;&#125;c.log();//오히려 전역객체 name 바뀜, 왜??window.name = 'Updated again! c object';//메소드의 this는 그 객체인데 변경이 안됐다? // Object &#123;name:'Updated c object', log: function&#125;// Object &#123;name:'Updated c object', log: function&#125; 메소드의 this는 속해있는 객체를 가르키지만, 또 메소드 내부 함수는 전역객체를 가르키는 오류가 있다. 이를 방지하기 위해서는 this를 변수에 명시적으로 지정해주고 그 변수를 활용하면 된다. 123456789101112131415161718var c = &#123; name: 'The C object'; log: function() &#123; var self = this; self.name = 'Updated c object'; console.log(this); // 메소드의 내부함수의 this는 또 전역을 가르키는 오류 있음 var setname = function(newName) &#123; self.name = newName; &#125; setName('Updated again! The c object'); console.log(self); &#125;&#125;c.log(); // Object &#123;name: 'Updated again! The c object'&#125; Related Postsarguments &amp; etc call By value &amp; referece","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"call by Value by Reference","slug":"jsw call-by","date":"2019-01-31T01:14:47.000Z","updated":"2019-05-03T07:22:09.649Z","comments":true,"path":"2019/01/31/jsw call-by/","link":"","permalink":"http://mingguk.github.io/2019/01/31/jsw call-by/","excerpt":"","text":"by Value 말 그대로 같은 ‘Value, 값’만 복사하고 각기 다른 메모리공간에 저장 따라서 a 나 b 의 값을 바꾼다고 해도 서로의 값에 영향을 주지 않는다 by Reference 메모리 상 해당 객체의 주소, reference를 복사하기 때문에 각기 다른 변수에 할당하더라도 모두 메모리상 같은 공간을 가르킨다.(해당 주소의 같은 메모리공간) 따라서 해당 객체를 변경하면 그에 연결된 모든 변수들이 영향을 받음 12345678910111213141516171819202122232425262728293031//by Value (primitives)var a = 3;var b;b = a;a = 2;console.log(a); // 2console.log(b); // 3//by Reference (Objects including functions)var c = &#123; greeting: &apos;hi&#125;;var d;// 객체이니 새로운 메모리 공간 할당x//c 가 가르키는 메모리상 같은 공간을 d도 가르키도록 함d = c; c.greeting = &apos;hello&apos;; // mutate// 같은 주소상 같은 객체를 변경했기 때문에 둘다 영향 받음console.log(c); // Object &#123; greeting: &apos;hello&apos;&#125;console.log(d); // Object &#123; greeting: &apos;hello&apos;&#125;//by Reference (even as parameters)function changeGreeting(obj) &#123; obj.greeting = &apos;Hola!&apos;;&#125;changeGreeting(d);console.log(c); // Object &#123; greeting: &apos;Hola!&apos;&#125; 주의 할 점 12345// = 연산자를 사용하면 새로운 메모리공간을 할당한다c = &#123;greeting: 'howdy'&#125;;console.log(c); // Object &#123; greeting: 'howdy'&#125;console.log(d); Object &#123; greeting: 'Hola!'&#125; Related PostsFunctions","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"Functions","slug":"jsw Functions","date":"2019-01-30T22:45:11.000Z","updated":"2019-05-03T07:11:30.920Z","comments":true,"path":"2019/01/31/jsw Functions/","link":"","permalink":"http://mingguk.github.io/2019/01/31/jsw Functions/","excerpt":"","text":"자바스크립트에서 function, 함수는 특별한 property를 가진 객체이다. name : Optional, 익명도 가능 작성한 코드의 Reference code : 작성한 코드, invocable() 이라는 작성한 코드를 실행시키는 특성을 가지고 있다. 이 두가지 property를 통해 자바스크립트에서 함수는 다른 변수나 객체가 하는 모든 역할들을 수행할 수 있다. (First Class Function, 1급 함수) 뒤에 나올 함수형 프로그래밍도 이 함수를 다른 함수의 인자로 넘길 수 있는 특성을 활용한 프로그래밍 기법의 일환이다. 1234567function greet() &#123; console.log('hi');&#125;// 함수는 객체이기 때문에 . 연산자 사용이 가능하다greet.language = 'english';console.log(greet.language); //english 위와 같이 함수를 생성하면 다른 객체처럼 메모리에 저장되고 이 함수는 NAME 과 CODE 를 가지기 때문에 이 함수를 호출 greet() 하면 작성한 코드를 invocable() 통해 실행 하게 된다. 아래의 코드를 확인해보자 123456789101112function log(a) &#123; console.log(a);&#125;log('a'); // alog(3); // 3log(&#123;greeting:'hi'&#125;) // Object &#123;greeting: 'hi'&#125;;// 함수가 객체이기에 인자로 넣을 수 있음log(function() &#123; console.log('Hello'); // function() &#123;console.log('hi')&#125;&#125;); 만약 코드 마지막 줄에 인자로 넣은 함수를 실행한 결과값을 얻고 싶다면? 12345678// log 함수를 인자를 호출하는 식으로 변경function log(a) &#123; a();&#125;log(function() &#123; console.log('hi'); // hi &#125;); Function statements &amp; Expressions자바스크립트에서 expression란 특정 value를 리턴하는 코드를 말한다 1234//expressionsa = 3 // 31 + 2; // 3a = &#123; greeting: 'hi'&#125; // Object &#123;greeting: 'hi'&#125; 반면에 statement 란 리턴이 없는 코드를 의미한다 1234//statementfunction greet() &#123; console.log('hi');&#125; Anonymous Function 익명함수는 이름이 없는 함수를 의미한다 12345678// anonymous function, 이경우에는 익명함수가 Object를 반환// 변수에 할당하기에 expression 이라고 볼 수 있음var anonymousGreet = function() &#123; console.log('hi);&#125;// 할당한 변수명 + () 통해 호출 할 수 있다anonymousGreet(); 아래코드의 실행결과를 살펴보자 12345678910111213141516greet();//Hoisting 에 의해 함수는 미리 메모리에 셋업되기 때문에 hi 출력 function greet() &#123; console.log('hi');&#125;// 변수에 할당 되었기에 현재 undefined anonymousGreet();var anonymousGreet = function() &#123; console.log('hi');&#125;// hi//uncaught type error, undefined is not a function... Related Postscall By value &amp; referece Object","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"Object","slug":"jsw Object","date":"2019-01-30T16:34:53.000Z","updated":"2019-05-03T07:21:20.261Z","comments":true,"path":"2019/01/31/jsw Object/","link":"","permalink":"http://mingguk.github.io/2019/01/31/jsw Object/","excerpt":"","text":"Object in javascript 자바스크립트에서 객체는 a collection of key value pairs 이다. 객체의 요소로 변수, 함수(메소드), 심지어 다른 객체 까지 가질 수 있고 각각의 요소에 대한 reference(메모리 어디에 저장되어있는지, 주소) 를 가지고 있다 123456789101112131415161718192021222324252627var person = new Object();// [] 는 연산자, 해당 객체의 name 주소로 가서 value 를 반환하는person['firstname'] = 'minkuk'; // name value pair// firstname 의 reference를 객체 person에게 부여person['lastname'] = 'Seo';var firstNameProperty = 'firstname';console.log(person); //Objectconsole.log(person[firstNameProperty]); //Tony// . 또한 연산자 a.name --&gt; a 객체의 name 의 value에 접근가능console.log(person.firstname); //Tony//객체 내 요소 추가하기person.address = new Object();person.address.street = '111 Main St.';person.address.city = 'New York';person.address.state = 'NY';//. 연산자로 객체의 요소들에 접근, 참조가능console.log(person.address.street) // 111 Main St.console.log(person.address.city) // New Yorkconsole.log(person['address']['state']) // NY Object literals123456789101112131415161718192021222324var person = &#123;&#125;; // 객체 생성 var person = &#123; firstname: 'minkuk', lastname: 'Seo' //다른 객체도 객체의 요소로 생성가능 address: &#123; street: '111 Main St.', city: 'New York', state: 'NY' &#125; &#125;; //객체는 함수의 인자로도 전달이 가능하다function greet(person) &#123; console.log('Hi ' + person.firstname);&#125;greet(Tony); // Hi Tony// 이런식으로 객체생성과 동시에 인자로 넘기기도 가능greet(&#123; firstname: 'Mary', lastname: Doe&#125;); // Hi Mary Doe NameSpace12345var greet = 'Hello!';var greet = 'Hola!';console.log(greet); // Hola! 자바스크립트는 순차적으로 코드를 실행하기 때문에 위의 결과를 예측하기는 쉽다. 하지만 만약에 각 변수가 다른 자바스크립트에 저장되어 있거나, 외부에서 라이브러리로 가져다 쓰는거라면? 의도치 않게 같은 변수명으로 인해 충돌 가능성이 있다. 이러한 충돌을 방지하기 위해 Namespace 개념이 발생했다. 자바스크립트에서는 객체를 이 네임스페이스로 활용 할 수 있다 12345var english = &#123;greet: 'Hello!'&#125;;var spanish = &#123;greet: 'Hola!'&#125;;console.log(english.greet); //Hello!console.log(spanish.greet); //Hola! 객체 요소 추가 시 주의사항 1234567891011english.greeting.greet = 'Hi!'; //이런 식은 error 발생//. 연산자의 우선순위에 따라 (연관 left-to-right)//english.greeting은 undefined가 이기 때문에// 객체 내 새로운 요소를 생성할 때는 [] 연산자를 사용하거나english[greeting][greet] = 'Hi!';// 객체 생성과 동시에 요소를 추가하는 것을 추천english = &#123;greeting: &#123;greet:'Hi!'&#125;&#125;;console.log(english.greeting.greet); // Hi! Related PostsFunctions Type &amp; Operator","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"type & operator","slug":"jsw type&operator","date":"2019-01-30T13:26:41.000Z","updated":"2019-05-03T07:10:13.437Z","comments":true,"path":"2019/01/30/jsw type&operator/","link":"","permalink":"http://mingguk.github.io/2019/01/30/jsw type&operator/","excerpt":"","text":"Dynamic typing자바스크립트는 동적 타이핑 을 사용한다. 자바스크립트 엔진이 코드가 실행될 때 자동으로 변수들의 type을 확인함. Primitive typesa single value 를 의미 undefined (아무것도 없음, 변수에 명시적으로 undefined를 할당하지 말 것) null(아무것도 없음, 명시적으로 null 지정해도 괜찮음) Boolean Number String Symbol (ES6) Operator자바스크립트에서 연산자는 조금 특별한 방식으로 쓰여진 함수이다 인자들을 받아 하나의 결과값을 내는. 12345678var num = 3 + 4;+ (3,4);// 어딘가에 다른 방식으로 + 라는 function이 정의되어있기에 자바스크립트에서 연산자들 사용가능function + (a, b) &#123; return // add the two numbers&#125; Operator precedence (우선순위) &amp; Associativity(연관) Precedence - 어떤 연산을 먼저 처리 할 것인가 Associativity - 같은 우선순위를 가진 연산자끼리는 어떤걸 먼저 처리 할 것인가? Javascript 우선순위, 연관 확인 1234567// Precedence examplevar a = 3 + 4 * 5;console.log(a);// var a = (4 * 5) + 3 // 23 12345678910111213// Associativity examplevar a = 2, b = 3, c = 4;a = b = c;console.log(a);console.log(b);console.log(c);// assignment(=) 의 연관이 rigth-to-left 이기 때문에// 1)b = c 2) a = b 순으로 연산, 따라서 결과는//4 4 4 coercion 변수의 타입을 변형시키는 것 자바스크립트는 동적 타이핑 이기때문에 coercion이 빈번하게 발생 1234var a = 1 + '2';console.log(a);// '12' coercion 이 자바스크립트 엔진에 의해 자동으로 수행됨 1234567Number(false) // 0Number(true) // 1Number(undefined) // NaNNumber(null) // 0console.log(3 &lt; 2 &lt; 1); //true 왜!?!?(연관 left-to-right) 3 &lt; 2 = false =&gt;0 , 0 &lt; 1 = true coercion 자동변환으로 편의성도 제공하지만 위의 예제처럼 개발자(사람) 관점에서는 이해할 수 없는 오류를 발생시킬 가능성 내포, 주의가 필요함 123456789101112false == 0 // truenull == 0 // falsenull &lt; 1 // true\"\" == 0 // true\"\" == false // true//coercion 은 코드결과 예측을 불확실하게 만들 수 있다. (특히 == 연산자)//대신 '===', '!==' 연산자를 사용 할 것 추천3 === 3 // true3 === '3' // false Existence &amp; Booleans 12345678910111213141516171819var a;if (a) // 조건문 () 안에 들어가면 Boolean 으로 coercion 된다&#123; console.log('Something is there.');&#125;a = 0;if (a) // Boolean(0) =&gt; false , 0이라는 값이 있음에도 잘못된 결과를 유발, 이때는if (a || a === 0) &#123; console.log('Something is there.');&#125;// === 연산자 우선순위에 따라 a || true 가되고 || 연산자에 따라// 그 다음 a || true 를 따지면 최종적으로 괄호안 조건은 true 됨//Something is there Default Values 12345678function greet(name) &#123; // default value 지정하는 법 name = name || '&lt;Your name here&gt;'; console.log('Hello ' + name);&#125;greet('Tony'); //Hello Tonygreet(); // Hello &lt;Your name here&gt; Related PostsObject Context &amp; Lexical environment","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"웹개발 공부계획","slug":"webDev-plan","date":"2019-01-29T13:28:27.000Z","updated":"2019-03-27T05:10:28.515Z","comments":true,"path":"2019/01/29/webDev-plan/","link":"","permalink":"http://mingguk.github.io/2019/01/29/webDev-plan/","excerpt":"","text":"웹개발 공부 계획 References (위주로 큰 틀을 잡고 다른 소스들 참고) whatsdev front-end guide (강추) whats dev full-stack guide (강추) 프론트엔드 뭘 공부해야 하는가? 웹프론트엔드 개발자, 어떻게 준비? Developer roadmap 목표2019 / 7 / 29 까지! Fullstack web developer 실력 있는 웹개발자 (프리,1인개발 / 구직 선택가능 한 수준 / 최소 현업 3년차 상회 수준) full-stack 설계 및 구현 완.성 경험 (기획, 프로토타이핑, 설계, 프론트, 백엔드, 모바일 앱(리액트)) TT project 완성 및 출시 / 포트폴리오 사이트 완성 || 첫 외주 수주 까지 (Web + android + ios (react native) / backend 통합 결과물 완성하기) personal branding (포폴 사이트 구축 / 블로그 / 깃헙) 포트폴리오 및 브랜딩 ( 깃헙 / 블로그(개발공부, 포트폴리오 페이지 따로) ) What to learn-1. Front-end- JavacriptBasic javascript Deep dive into javascript ( OOP in javascript / functional programming / etc) Dom manupulation Es6 Framework (React / React Native) Modular js (Design pattern) Html / Csshtml /css basic responsive web design preprocessors (Sass, Gulp) CSS framework (Bootstrap / semantic UI / flex / grid / etc) Modul loader (Webpack) -2. Back-end- back - endNPM, Node js , Express Databases (relational / non-relational) Restfull api MVC architecture Authentication (JWT, oAuth 2.0) Authorization Testing (Mocha, Chai) Security SSR vs CSR Deployment (Docker, heroku, AWS, etc) -3. etc- Algorithms Git ssh, command line Prototying toos(Figma) / UX, UI basic design Blogging ( 공부내용 정리 / TIL / 프로젝트 정리) English (업무 진행, 커뮤니케이션 상회 수준 꼭!) Schedule1월 &lt;기초&gt;&lt;숲 파악&gt; 런코 전과정 마스터(발췌,보충) , 테스트 준비, 통과 udemy javascript weird parts 정리 (블로깅) udemy web dev bootcamp 일부 (런코 관련) ==&gt; javascript 기본개념, 사용법 정리 2월 &lt;프론트엔드&gt; 자바스크립트 작동원리, 개념정리, codestates pre course 복습 (블로깅) udemy web dev bootcamp (풀스택 사이클 경험 / js 연습) udemy algorithm in javascript (자료구조, 원리 이해, 직접 구현) 시작 codesates pre course 완강(사실상) (알고리즘, js skill up, 브랜딩, 블로깅은 항상 병행!!!) 3월 (웹퍼플리싱 기초 + js 심화 연습)– front -end 기초 공부 끝내기 (css , js 위주 / 토들러 프로젝트, 구현연습 위주)modern html&amp;css 끝, 체화 (내 포폴 사이트 기초 완성하기) Udemy Advanced CSS ans Sass course 완강 및 정리! Udemy modern js 끝, 체화 정리 / Udemy another js 코스도 완강, 정리 4월 (프론트엔드 프레임워크, 라이브러리 / 프론트엔드 포폴사이트 완성) html / css / js 기본 갈무리! 프로젝트 준비 algorithms in js 완강 정리! (code signal 매일 풀기) front-end portfolio site 완성 프론트엔드 프레임워크 (리액트 기초, 리액네이티브까지) 기초 완강 프로토타이핑 배우기 (FIgma / Adobe XD) 5월 (풀스택 시동걸기) 리액트, 리액트네이티브 완강 (노마드 + 유데미) Node.js npm … Database (PostgreSQL, MongoDB, Firebase, AWS…) 인스타 클론 선행 과목들 (Apollo m GraphQL, SC..) 6월 (풀스택 완강, 투어투게더 돌입) 노마드 인스타 풀스택 완성, 정리 풀스택 프로젝트 돌입 (투어투게더) 웹/안드/ios 통합! (PWA) 7~8월 (투어투게더 완성! / 커리어 시작 준비!) 투어투게더 런칭 / 개인브랜딩 정리(블로그, 포폴사이트, 기타) 포트폴리오 정리 ( 포폴 사이트, 블로그, 깃헙 등) 진로 결정 (구직 / 전업프리 / 기타) 2019년 까지첫 시스템 출시, 운영 경험 (투어투게더)다음 본격 시스템 구상 및 개발 커리어 진행! Related Posts","categories":[{"name":"post","slug":"post","permalink":"http://mingguk.github.io/categories/post/"}],"tags":[{"name":"plan","slug":"plan","permalink":"http://mingguk.github.io/tags/plan/"}]},{"title":"Context & Lexical Environments","slug":"jsw context &ex","date":"2019-01-29T03:21:31.000Z","updated":"2019-01-30T17:03:40.968Z","comments":true,"path":"2019/01/29/jsw context &ex/","link":"","permalink":"http://mingguk.github.io/2019/01/29/jsw context &ex/","excerpt":"","text":"자바스크립트를 이해하는데 있어 중요한 기본개념 3가지 Syntax parsers 작성한 코드를 컴퓨터가 이해 가능한 언어로 번역, 문법을 확인해주는 프로그램 Lexical environments프로그래밍 언어에서 lexical 이란 특정 단어나 문법과 연관이 있다는 의미로, 코드를 어느 위치 에 작성하느냐, 그 코드를 어떤것이 감싸고 있느냐 에 따라 전혀 다르게 작동한다는 의미 예를들어 위의 사진에서 변수 a는 hello 라는 함수 안에 위치하고 있기 때문에 hello() 내에서만 존재, 접근가능 Execution context lexical environments 중에서 어떤 환경을 선택해서 실행되는지를 관리하는 Wrapper 이다. Excution context (Global) 자바스크립트 코드를 실행하면 Execution context 생성 Global object(window), this 생성 Outer environment 생성 작성한 코드 실행 순으로 진행된다. 자바스크립트에서 말하는 Global(전역)은 Not in a function, 특정 객체나 함수가 아님 을 의미한다 즉, 특정 객채(함수) 안에 (lexical evironmental) 존재하지 않는다는 의미 Hoisting1234567891011(1)var a = &apos;Hello World&apos;;function b() &#123; console.log(&apos;Called b&apos;);&#125;b();console.log(a)// Called b// Hello World (1) 코드 실행결과를 예측하는 것은 쉬운 일이다. 123456789101112(2)b();console.log(a)var a = &apos;Hello World&apos;;function b() &#123; console.log(&apos;Called b&apos;);&#125;//called b// undefined 하지만 (2)는? 변수 a 는 undefined, 함수 b는 정상적으로 출력이 됐다. 이러한 현상을 호이스팅(Hoisting)이라고 한다. 몇몇 설명에서는 마치 코드를 물리적으로 최상단으로 이동시킨 다는 식인데 이는 오해의 소지가 있다. excution context는 두 단계가 있다 Creation phase 와 Excution phase Creation phase Execution context 가 생성되면 동시에 global object, this, outer environment를 생성하고 변수와 함수 저장을 위해 메모리공간을 먼저 할당한다. 이때 모든 변수는 먼저 undefined 로 할당되고 함수는 의도대로 할당되는데 이 과정을 Hoisting 이라고 한다. Execution phase 이 모든 작업 이후 코드가 한줄 한줄 순서대로 실행 되면서 의도한 값들이 해당 변수에 할당 됨. Function invokation자바스크립트에서 함수를 호출하면 어떤 일이 벌어질까? 12345678function b() &#123;&#125;function a() &#123; b();&#125;a(); Global Execution Context , Global Object, this 생성 메모리에 함수 a 와 b 를 위한 공간 셋업 한줄 한줄 실행하다 함수호출 a() 를 만나면 a() 를 위한 새로운 Execution context 를 생성후 Execution Stack 에 삽입 a() 함수 내부 로직을 실행한다 (in Execution context of a() ) 그러다 새로운 함수 호출 b() 를 만나면, b()를 위한 새로운 Execution contex를 생성, 같은 과정 반복 각 함수 실행이 끝나는 순서대로 Execution stack 에서 빼내는 순으로 작동이 종료된다 즉, 함수가 호출되어 실행 될 때마다 새로운 execution context가 생성되고, Execution stack 에 삽입, 함수 내부로직을 실행한 뒤에는 Execution stack 에서 빠지고 해당 Execution context 도 사라진다. 그 다음 해당 함수 호출 이후의 코드들이 순차적으로 실행되는 식으로 작동한다. 다음 코드의 실행순서를 살펴보면, a() 호출 (컨텍스트 생성, 스택 삽입) b() 호출 (컨텍스트 생성, 스택 삽입) var d b() out (컨텍스트 삭제, 스택에서 out) var c a() out (컨텍스트 삭제, 스택에서 out) var d 순으로 진행 될 것이다. Variable Environment 각 함수가 호출될때마다 새로운 Execution context 가 추가되고, 변수 myVar는 각각의 Execution context 내에 독립적으로 존재, 각기 다른 메모리공간에 할당된다. 12345678910111213141516171819function b() &#123; var myVar; console.log(myVar);&#125;function a() &#123; var myVar = 2; console.log(myVar); b(); &#125;var myVar = 1;console.log(myVar);a();console.log(myVar);//1//2//undefined//1 변수는 결국 어떤 Execution context 내의 variable environment 속해있는가 에 따라 결정되고 이는 곧 스코프(scope) 개념으로 연결된다. Scope Chain함수가 호출될 때 자바스크립트 엔진은 해당 함수가 ‘’어디” 에 작성됐는지를 기반으로 해당 Execution context의 outer environment 에 대한 reference 를 생성한다. 자기가 속한 Execution context 에서 해당 변수를 찾지 못했다면, outer environment reference 가 가르키는 Execution context 에서 다시 해당 변수를 검색하고.. 그 끝은 결국 전역, Globla Execution context 까지 이른다. 123456789101112function b() &#123; console.log(myVar);&#125;function a() &#123; var myVar = 2; b();&#125;var myVar = 1;a();//1 b() Execution context 에는 변수 myVar 가 없다. 따라서 outer environment 인 Global Execution context 에서 myVar=1 확인 console.log(myVar) ==&gt; 1 1234567891011function a() &#123; function b() &#123; console.log(myVar); &#125; var myVar = 2; b();&#125;var myVar = 1;a(); 위의 코드의 경우 Outer environment 는 b() ==&gt; a() ==&gt; Global execution 순으로 Scope chain 이 결정 될 것이다. 따라서 해당 함수가 어느 Execution context에 정의 되었는지 확인하면 (코드 내 어디에서 선언되었는지) scope chain을 확인 할 수있다. Asynchronous Callback자바스크립트는 동기식 (한번에 하나의 작업처리 순서대로). 동시에 여러개 처리 못함, 자바스크립트는 코드 한줄 한줄 순서대로 실행! 자바스크립트 엔진에는 Execution stack 외에 여러 이벤트들을 담는 Event queue 가 존재한다. 자바스크립트 엔진은 Event queue 를 계속 주시하고 있고, Execution stack이 빈상태가 됐을 때 (순차적으로 실행할 함수들이 다 실행되고 나면) , queue에 있는 이벤트가 발동되면 해당 이벤트의 콜백함수 ( ex) click , clickHandler() ) 를 Execution stack 으로 삽입시켜 함수를 실행하게 한다. ​ 1234567891011121314151617181920// 3초가 지나면 종료되는 함수function waitThreeSeconds() &#123; var ms = 3000 + new Date().getTime(); while (new Date() &lt; ms) &#123;&#125; console.log(&apos;finished function&apos;);&#125;function clickHandler() &#123; console.log(&apos;click event!&apos;);&#125;// 웹페이지 아무대나 클릭하면 발동되도록 리스너 추가document.addEventListener(&apos;click&apos;, clickHandler);waitThreeSeconds();console.log(&apos;finished execution&apos;);//3초 이전에 클릭이벤트를 발생시켜도 결과는 아래와 같다//finished function//finished execution//click event! 위의 코드실행 결과가 왜 저 순서대로 나오는지 이해가 되는가? waitThreeSeconds() 는 3초가 지나면 실행을 종료한다 ( Execution context 사라짐) -&gt; 한줄한줄 코드를 실행하다 끝에 다다른다 (Global Execution context 사라짐) -&gt; Execution stack 빔 -&gt; 그때서야 event queue 확인 -&gt; 해당 event handler() 실행 즉, 자바스크립트 엔진은 Execution stack 이 비워지기 전까지 event queue를 처리하지 않다가 스택이 비게되면(코드를 순차적으로 다 실행하고 나서야) event queue 내에 준비된 event를 처리한다. 이것이 자바스크립트가 동기식으로 비동기식 작업을 처리하는 방식이다. Related PostsType &amp; Operator Main","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"<Udemy> Javascript weird parts 시작하기","slug":"jsw main","date":"2019-01-29T02:15:51.000Z","updated":"2019-01-30T17:29:13.202Z","comments":true,"path":"2019/01/29/jsw main/","link":"","permalink":"http://mingguk.github.io/2019/01/29/jsw main/","excerpt":"","text":"자바스크립트 개념정리를 위해 이러저리 자료를 찾던중 발견한 보석같은 강의 (feat. 연쇄할인마) 단순 문법이나 기초 예제 복기가 아닌 이면에 자바스크립트가 어떻게 동작하는지 그 원리를(weird parts) 이해하는 것을 목표로 하고 있다. 굳이 왜 작동원리까지..? 라고 생각 할 수 있겠지만 원리에 대한 이해를 바탕으로 더 나은 코드를 작성할 수 있다는 주장이다. 1console.log(&apos;Hello World&apos;); //Hello World 예를들어 Hello world 를 출력하기 위한 이 간단한 코드 이면에, 이를 실행하기 위해 자바스크립트엔진이 어떻게 동작하여 브라우저를 통해 화면에 글자를 출력하게 되는지 같은.. 사실 codestates pre 과정에서 처음하는 javascript임에도 큰 혼란을 겪지않았던건 먼저 이 강의를 수강하고 간 덕분인것 같다. 프론트엔드 개발에 흔히 쓰이는 프레임워크, 라이브러리들도 결국 자바스크립트 코드일뿐 이라는 것, 프론트엔드 개발을 잘하고 싶다, 코드 퀄리티를 높히고 싶다면? 결국 모든것의 기반이 되는 자바스크립트를 깊게 파고 공부하는 것이 최선의 방법 pre course 공부한 내용이랑 자바스크립트 개념 정리를 위해서 시리즈로 블로그에 정리 포스팅을 연재 할 계획이다 그다음은 오래전 결제하고 조금보다 방치한 web bootcamp 랑 javascript real projects 를 완강하고.. Related PostsJSW context &amp; scope","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"back","slug":"back","date":"2019-01-28T16:22:52.000Z","updated":"2019-01-30T13:51:14.386Z","comments":true,"path":"2019/01/29/back/","link":"","permalink":"http://mingguk.github.io/2019/01/29/back/","excerpt":"","text":"백엔드 카테고리 Related Posts","categories":[{"name":"Back","slug":"Back","permalink":"http://mingguk.github.io/categories/Back/"}],"tags":[{"name":"back","slug":"back","permalink":"http://mingguk.github.io/tags/back/"}]},{"title":"review","slug":"review","date":"2019-01-28T16:11:57.000Z","updated":"2019-01-30T13:51:04.047Z","comments":true,"path":"2019/01/29/review/","link":"","permalink":"http://mingguk.github.io/2019/01/29/review/","excerpt":"","text":"안녕하세요주로 온라인 강의 나 부트캠프로 공부를 많이 해왔기 때문에 (영어 자료 위주) 필요한 인강의나 강의 선택 시 제 경험이 작은 도움이 됏으면 합니다 주로 강의를 듣는 사이트 Udemy Udacity 인프런 칸아카데미, 코드리뷰 Related post코드스테이츠 pre course 후기","categories":[{"name":"Review","slug":"Review","permalink":"http://mingguk.github.io/categories/Review/"}],"tags":[{"name":"review","slug":"review","permalink":"http://mingguk.github.io/tags/review/"}]},{"title":"코드스테이츠 pre course 후기","slug":"codestates","date":"2019-01-27T21:48:43.000Z","updated":"2019-05-03T06:53:25.841Z","comments":true,"path":"2019/01/28/codestates/","link":"","permalink":"http://mingguk.github.io/2019/01/28/codestates/","excerpt":"","text":"아재, 비전공, 수포자 프로그래밍 도전기 3관 타이틀로 과연 개발자가 될 수 있을까?우연히 관심갖게 된 코딩, 온라인강의나 독학을 전전하며 큰 성과없이 있다, 문득 더 늦기 전에 도전해봐야겠다는 생각에 시작한 code states pre course, 시작한지 어느덧 벌써 한달이 지나갔다.지난 한달간 대부분의 시간과 노력을 투자 했음에도 시작 단계라고 만만히 봤던 pre course는 생각보다 훨씬 ‘빡세고’ ,‘외로운’ 과정이었다 티칭 이 아니라 ‘코칭?’ 솔직히 처음엔 코드스테이츠 측에서 딱히 가르쳐 주는 거 없이 너무 날로(?) 하는거 아닌가라는 불만도 있었다 수업이나 강의를 통해 지식을 전달 받고, pair programming 을 통해 거 의견을 공유하면서 같이 코딩을 하는 시간도 있었다 하지만. 대부분은 부여받은 과제를 해결하기 위해 홀로 이리저리 머리를 짜내고 시도하고, 필요한 부분들을 검색해서 다른 방식으로 접근해보는 식의 연속이었다 시작할때는 뭘 하라는건지 감조차 못잡던 문제들을 직접 부딪혀쳐가며 하나하나 해결해 나가는 과정속에서 나도 모르게 sudo code를 끄적거리고, 내가 생각한 기능을 지원하는 메소드가 있는지 , 이걸 해결하기 위해 내가 모르는게 뭔지, 뭘 공부해야 되는지 검색하고 다시 시도해보는 식의 습관이 자리잡은 것 같다 해결한 과제가 하나 둘 쌓여 갈수록 점점 코드 스테이츠의 방식에 대한 확신이 강해졌다 결국 문제해결능력 아직 잘 모르지만, 지인들이나 회사에서 간접적으로 경험했던 개발자들의 모습, 그리고 pre course 를 진행하면서 느낀 것들을 종합해 보자면 결국 개발자의 실력이란 현장에서 직면하는 문제들을 이미 알고 있는 지식으로, 혹은 모르지만 필요한 것들을 빠르게 습득, 적용하여 효율적으로 문제를 해결하는 것 아닐까? 한가지 덧붙이자면 상용 어플리케이션의 규모상 혼자가 아닌 ‘함께 문제를 잘 해결 해내는 능력’ 까지 ‘코칭’ 측면에서 codestates 의 가치? 나는 무엇인가를 배울 때 가장 중요한 것은 ‘내가 뭘 모르는지 정확히 아는것’ 이라고 생각한다 거기서 명확한 계획과 전략이 나오고 노력이 뒷받침 된다면 성공 할 수 있다고 믿는다 비싼 돈 들여 원어민 강사있는 학원에 가도 영어를 유창하게 배울 확률은 매우 낮다 그 원어민 강사들을 당신이 영어의 어떤 부분을 모르고 부족해서 영어가 안되는지 알지 못한다 (혹은 돈이 안되기 때문에 알면서 외면하거나) 코칭은 대상의 현재 상태와 목표간의 괴리를 객관적으로 파악하고 목표달성을 위한 명확한 방향과 방법을 제시, 서포팅 하는 역할이다 질의응답이나, pre course 러닝코드 프로그램을 진행하면서 코드스테이츠는 수강생들이 뭘 모르고 어려워하는지, 어떤식으로 도와줘야 되는지 잘 안다는 느낌을 받았다아마 과정을 설계한 엔지니어와 직원들 중 다수가 이전에 codestates 과정들을 이수했기 때문이라고 생각된다 나 포함 비전공, 생에 첫 코딩, 무관심자들을 진짜 제대로된 개발자로 만들어내기 위해 코드스테이츠가 제시하는 솔루션은 결국 개발자의 본질, ‘문제해결능력’을 키울 수 있도록 잘 유도하는 하는 것 같다 잘 짜여진 시스템과 단계별로 적당히 도전적 난이도로 설계된 과제들로 이끌어 주고, 개발에 집중 할 수 있는 환경조성, 질의응답, 서포트 역할 등..개인적으로 기대 이상 이었고 충분히 만족스러웠다 이러한 강점들은 정해진 가이드라인이 있는 pre course 보다 각자 프로젝트를 기획, 설계부터 구현까지 스스로 해내야 하는 immersive course 에서 더 빛을 발하지 않을까 생각된다 pre course를 잘 마무리하고 다음 과정인 immersive course 을 통해 제대로 된 개발자로의 커리어 전환에 진지하게 도전해 볼 생각이다 그동안 주입식, 강의식에 질리고 만족스러운 결과를 얻지 못했다면, 개발을 어떻게 배워야되는지 감을 잡지 못했다면 codestates 를 추천하고 싶다물론 훨씬 고된길이 되겠지만.. 기타사항들 학습 환경이 좋다. 성수 패스트파이브 건물 6층 전체, 나머지 층 공유하는거 같은데 오프라인 수강이면 자습환경도 제공한다 (편한자리, 모니터 지원, 5층 카페테리아 공간에서 커피, 음료, 에일맥주 무료 제공) 코딩 외에 다른 지원에도 신경 많이 쓰는거 같다 (면접,이력서,협상 등 커리어 관련 / 수강료 부담 관련 we-win제도 / 생활관련 / 학습환경 조성 등 ) 빠른 피드백(온라인 채널) 최애 성수족발이랑 가깝다.. Related Postshttps://www.codestates.com/ https://mingguk.github.io","categories":[{"name":"Review","slug":"Review","permalink":"http://mingguk.github.io/categories/Review/"},{"name":"Bootcamp","slug":"Review/Bootcamp","permalink":"http://mingguk.github.io/categories/Review/Bootcamp/"}],"tags":[{"name":"codestates","slug":"codestates","permalink":"http://mingguk.github.io/tags/codestates/"},{"name":"코드스테이츠","slug":"코드스테이츠","permalink":"http://mingguk.github.io/tags/코드스테이츠/"}]},{"title":"first post","slug":"first-post","date":"2019-01-27T21:20:23.000Z","updated":"2019-01-30T13:49:35.522Z","comments":true,"path":"2019/01/28/first-post/","link":"","permalink":"http://mingguk.github.io/2019/01/28/first-post/","excerpt":"","text":"처음이라니헥소 블로그 세팅 헬.. Related PostsJavascript 시리즈 2: 자바스크립트 엔진","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"}]}]}