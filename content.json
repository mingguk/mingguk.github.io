{"meta":{"title":"Mingguk","subtitle":null,"description":null,"author":"minkuk Seo","url":"http://mingguk.github.io"},"pages":[],"posts":[{"title":"Functions","slug":"jsw Functions","date":"2019-01-30T22:45:11.000Z","updated":"2019-01-30T13:47:53.791Z","comments":true,"path":"2019/01/31/jsw Functions/","link":"","permalink":"http://mingguk.github.io/2019/01/31/jsw Functions/","excerpt":"","text":"Related Posts","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"Object","slug":"jsw Object","date":"2019-01-30T16:34:53.000Z","updated":"2019-01-30T13:50:37.121Z","comments":true,"path":"2019/01/31/jsw Object/","link":"","permalink":"http://mingguk.github.io/2019/01/31/jsw Object/","excerpt":"","text":"Object in javascript 자바스크립트에서 객체는 a collection of key value pairs 이다. 객체의 요소로 변수, 함수(메소드), 심지어 다른 객체 까지 가질 수 있고 각각의 요소에 대한 reference(메모리 어디에 저장되어있는지, 주소) 를 가지고 있다 123456789101112131415161718192021222324252627var person = new Object();// [] 는 연산자, 해당 객체의 name 주소로 가서 value 를 반환하는person[&apos;firstname&apos;] = &apos;minkuk&apos;; // name value pair// firstname 의 reference를 객체 person에게 부여person[&apos;lastname&apos;] = &apos;Seo&apos;;var firstNameProperty = &apos;firstname&apos;;console.log(person); //Objectconsole.log(person[firstNameProperty]); //Tony// . 또한 연산자 a.name --&gt; a 객체의 name 의 value에 접근가능console.log(person.firstname); //Tony//객체 내 요소 추가하기person.address = new Object();person.address.street = &apos;111 Main St.&apos;;person.address.city = &apos;New York&apos;;person.address.state = &apos;NY&apos;;//. 연산자로 객체의 요소들에 접근, 참조가능console.log(person.address.street) // 111 Main St.console.log(person.address.city) // New Yorkconsole.log(person[&apos;address&apos;][&apos;state&apos;]) // NY Object literals123456789101112131415161718192021222324var person = &#123;&#125;; // 객체 생성 var person = &#123; firstname: &apos;minkuk&apos;, lastname: &apos;Seo&apos; //다른 객체도 객체의 요소로 생성가능 address: &#123; street: &apos;111 Main St.&apos;, city: &apos;New York&apos;, state: &apos;NY&apos; &#125; &#125;; //객체는 함수의 인자로도 전달이 가능하다function greet(person) &#123; console.log(&apos;Hi &apos; + person.firstname);&#125;greet(Tony); // Hi Tony// 이런식으로 객체생성과 동시에 인자로 넘기기도 가능greet(&#123; firstname: &apos;Mary&apos;, lastname: Doe&#125;); // Hi Mary Doe NameSpace12345var greet = &apos;Hello!&apos;;var greet = &apos;Hola!&apos;;console.log(greet); // Hola! 자바스크립트는 순차적으로 코드를 실행하기 때문에 위의 결과를 예측하기는 쉽다. 하지만 만약에 각 변수가 다른 자바스크립트에 저장되어 있거나, 외부에서 라이브러리로 가져다 쓰는거라면? 의도치 않게 같은 변수명으로 인해 충돌 가능성이 있다. 이러한 충돌을 방지하기 위해 Namespace 개념이 발생했다. 자바스크립트에서는 객체를 이 네임스페이스로 활용 할 수 있다 12345var english = &#123;greet: &apos;Hello!&apos;&#125;;var spanish = &#123;greet: &apos;Hola!&apos;&#125;;console.log(english.greet); //Hello!console.log(spanish.greet); //Hola! 객체 요소 추가 시 주의사항 1234567891011english.greeting.greet = &apos;Hi!&apos;; //이런 식은 error 발생//. 연산자의 우선순위에 따라 (연관 left-to-right)//english.greeting은 undefined가 이기 때문에// 객체 내 새로운 요소를 생성할 때는 [] 연산자를 사용하거나english[greeting][greet] = &apos;Hi!&apos;;// 객체 생성과 동시에 요소를 추가하는 것을 추천english = &#123;greeting: &#123;greet:&apos;Hi!&apos;&#125;&#125;;console.log(english.greeting.greet); // Hi! Related PostsType &amp; Operator","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"type & operator","slug":"jsw type&operator","date":"2019-01-30T13:26:41.000Z","updated":"2019-01-30T12:45:43.615Z","comments":true,"path":"2019/01/30/jsw type&operator/","link":"","permalink":"http://mingguk.github.io/2019/01/30/jsw type&operator/","excerpt":"","text":"Dynamic typing자바스크립트는 동적 타이핑 을 사용한다. 자바스크립트 엔진이 코드가 실행될 때 자동으로 변수들의 type을 확인함. Primitive typesa single value 를 의미 undefined (아무것도 없음, 변수에 명시적으로 undefined를 할당하지 말 것) null(아무것도 없음, 명시적으로 null 지정해도 괜찮음) Boolean Number String Symbol (ES6) Operator자바스크립트에서 연산자는 조금 특별한 방식으로 쓰여진 함수이다 인자들을 받아 하나의 결과값을 내는. 12345678var num = 3 + 4;+ (3,4);// 어딘가에 다른 방식으로 + 라는 function이 정의되어있기에 자바스크립트에서 연산자들 사용가능function + (a, b) &#123; return // add the two numbers&#125; Operator precedence (우선순위) &amp; Associativity(연관) Precedence - 어떤 연산을 먼저 처리 할 것인가 Associativity - 같은 우선순위를 가진 연산자끼리는 어떤걸 먼저 처리 할 것인가? Javascript 우선순위, 연관 확인 1234567// Precedence examplevar a = 3 + 4 * 5;console.log(a);// var a = (4 * 5) + 3 // 23 12345678910111213// Associativity examplevar a = 2, b = 3, c = 4;a = b = c;console.log(a);console.log(b);console.log(c);// assignment(=) 의 연관이 rigth-to-left 이기 때문에// 1)b = c 2) a = b 순으로 연산, 따라서 결과는//4 4 4 coercion 변수의 타입을 변형시키는 것 자바스크립트는 동적 타이핑 이기때문에 coercion이 빈번하게 발생 1234var a = 1 + &apos;2&apos;;console.log(a);// &apos;12&apos; coercion 이 자바스크립트 엔진에 의해 자동으로 수행됨 1234567Number(false) // 0Number(true) // 1Number(undefined) // NaNNumber(null) // 0console.log(3 &lt; 2 &lt; 1); //true 왜!?!?(연관 left-to-right) 3 &lt; 2 = false =&gt;0 , 0 &lt; 1 = true coercion 자동변환으로 편의성도 제공하지만 위의 예제처럼 개발자(사람) 관점에서는 이해할 수 없는 오류를 발생시킬 가능성 내포, 주의가 필요함 123456789101112false == 0 // truenull == 0 // falsenull &lt; 1 // true&quot;&quot; == 0 // true&quot;&quot; == false // true//coercion 은 코드결과 예측을 불확실하게 만들 수 있다. (특히 == 연산자)//대신 &apos;===&apos;, &apos;!==&apos; 연산자를 사용 할 것 추천3 === 3 // true3 === &apos;3&apos; // false Existence &amp; Booleans 12345678910111213141516171819var a;if (a) // 조건문 () 안에 들어가면 Boolean 으로 coercion 된다&#123; console.log(&apos;Something is there.&apos;);&#125;a = 0;if (a) // Boolean(0) =&gt; false , 0이라는 값이 있음에도 잘못된 결과를 유발, 이때는if (a || a === 0) &#123; console.log(&apos;Something is there.&apos;);&#125;// === 연산자 우선순위에 따라 a || true 가되고 || 연산자에 따라// 그 다음 a || true 를 따지면 최종적으로 괄호안 조건은 true 됨//Something is there Default Values 12345678function greet(name) &#123; // default value 지정하는 법 name = name || &apos;&lt;Your name here&gt;&apos;; console.log(&apos;Hello &apos; + name);&#125;greet(&apos;Tony&apos;); //Hello Tonygreet(); // Hello &lt;Your name here&gt; Related PostsObject &amp; Functions [1] Context &amp; Lexical environment","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"webDev study plan","slug":"webDev-plan","date":"2019-01-29T13:28:27.000Z","updated":"2019-01-30T13:50:51.632Z","comments":true,"path":"2019/01/29/webDev-plan/","link":"","permalink":"http://mingguk.github.io/2019/01/29/webDev-plan/","excerpt":"","text":"웹개발 공부 계획 References (위주로 큰 틀을 잡고 다른 소스들 참고) 프론트엔드 뭘 공부해야 하는가? 웹프론트엔드 개발자, 어떻게 준비? Developer roadmap 1. Javascript 자바스크립트 동작원리 자바스크립트 문법, 주요개념 DOM ES6 자바스크립트 생태계 (npm Web pack / bable) CommonJS OOP in Javascript / 함수형 프로그래밍 Type script AJAX CORS 2. HTML / CSS grid Midea query CSS Framework (Bootsctrap 4 웹 접근성 3. library framework react 상태관리 라이브러리 react native 4. CS , Network, algorithm 자료구조 알고리즘 (Udemy, daily toy, 면접대비) 5. Backend 서버사이드 / 클라이언트 사이드 렌더링 node js graphQL MongoDB 6. Etc Github Blogging Terminal usage Design patterns English (업무수준 상회) Schedule1월 &lt;기초&gt;&lt;숲 파악&gt;** 런코 전과정 마스터(발췌,보충) , 테스트 준비, 통과 udemy javascript weird parts 정리 (블로깅) udemy web dev bootcamp 일부 (런코 관련) ==&gt; javascript 기본개념, 사용법 정리 2월 &lt;프론트엔드&gt; 자바스크립트 작동원리, 개념정리, codestates pre course 복습 (블로깅) udemy web dev bootcamp 완강, udemy javascript build real app 완강 (js 로 웹 실제 조작, 구현 경험) udemy algorithm in javascript (자료구조, 원리 이해, 직접 구현)udemy network 이론강의 수강 , 컴원리 포함 생태계, javascript 관련 필수 이슈들 HTML / CSS (udemy Html/css 강의 / 미디어쿼리) 3월~4.11 &lt;풀스택 경험 + 백엔드 기초&gt; &lt;갈무리&gt; 라이브러리 (react , react native 기초 공부) - udemy / nomad react 기초강의들 nomad coder 풀스택 과정 1개 수료 (유튜브 or 우버 or 클론) 그동안 공부한 것 정리 (블로그 - TIL ,특수 주1회 / 깃헙) / 알고리즘 지속 공부 4월~ 수료까지 Codetates immersive course 목표 : 실력 있는 프론트엔드 개발자 &amp;&amp; 웹개발 커리어 시작 지속 학습능력 (스스로 배우는 방법 터득, 체화) 커뮤니케이션, 협업 능력 (혼자 보다 함께, 더 크게) 기본기 갖추기 (cs, 네트워크 / 알고리즘 / 기반 작동원리 파악) full-stack 설계 및 구현 경험 ( front 기반 + backend 기초 구축, 어플리케이션 전체) Web + android + ios (react native) / backend 통합 결과물 완성하기 포트폴리오 및 브랜딩 ( 깃헙 / 블로그(개발공부, 포트폴리오 페이지 따로) ) Related Posts","categories":[{"name":"post","slug":"post","permalink":"http://mingguk.github.io/categories/post/"}],"tags":[{"name":"plan","slug":"plan","permalink":"http://mingguk.github.io/tags/plan/"}]},{"title":"Context & Lexical Environments","slug":"jsw context &ex","date":"2019-01-29T03:21:31.000Z","updated":"2019-01-30T11:29:00.531Z","comments":true,"path":"2019/01/29/jsw context &ex/","link":"","permalink":"http://mingguk.github.io/2019/01/29/jsw context &ex/","excerpt":"","text":"자바스크립트를 이해하는데 있어 중요한 기본개념 3가지 Syntax parsers 작성한 코드를 컴퓨터가 이해 가능한 언어로 번역, 문법을 확인해주는 프로그램 Lexical environments프로그래밍 언어에서 lexical 이란 특정 단어나 문법과 연관이 있다는 의미로, 코드를 어느 위치 에 작성하느냐, 그 코드를 어떤것이 감싸고 있느냐 에 따라 전혀 다르게 작동한다는 의미 예를들어 위의 사진에서 변수 a는 hello 라는 함수 안에 위치하고 있기 때문에 hello() 내에서만 존재, 접근가능 Execution context lexical environments 중에서 어떤 환경을 선택해서 실행되는지를 관리하는 Wrapper 이다. Excution context (Global)자바스크립트 코드를 실행하면 Execution context 생성 Global object(window), this 생성 Outer environment 생성 작성한 코드 실행 순으로 진행된다. 자바스크립트에서 말하는 Global(전역)은 Not in a function, 특정 객체나 함수가 아님 을 의미한다 즉, 특정 객채(함수) 안에 (lexical evironmental) 존재하지 않는다는 의미 Hoisting1234567891011(1)var a = &apos;Hello World&apos;;function b() &#123; console.log(&apos;Called b&apos;);&#125;b();console.log(a)// Called b// Hello World (1) 코드 실행결과를 예측하는 것은 쉬운 일이다. 123456789101112(2)b();console.log(a)var a = &apos;Hello World&apos;;function b() &#123; console.log(&apos;Called b&apos;);&#125;//called b// undefined 하지만 (2)는? 변수 a 는 undefined, 함수 b는 정상적으로 출력이 됐다. 이러한 현상을 호이스팅(Hoisting)이라고 한다. 몇몇 설명에서는 마치 코드를 물리적으로 최상단으로 이동시킨 다는 식인데 이는 오해의 소지가 있다. excution context는 두 단계가 있다 Creation phase 와 Excution phase Creation phase Execution context 가 생성되면 동시에 global object, this, outer environment를 생성하고 변수와 함수 저장을 위해 메모리공간을 먼저 할당한다. 이때 모든 변수는 먼저 undefined 로 할당되고 함수는 의도대로 할당되는데 이 과정을 Hoisting 이라고 한다. Execution phase 이 모든 작업 이후 코드가 한줄 한줄 순서대로 실행 되면서 의도한 값들이 해당 변수에 할당 됨. Function invokation자바스크립트에서 함수를 호출하면 어떤 일이 벌어질까? 12345678function b() &#123;&#125;function a() &#123; b();&#125;a(); Global Execution Context , Global Object, this 생성 메모리에 함수 a 와 b 를 위한 공간 셋업 한줄 한줄 실행하다 함수호출 a() 를 만나면 a() 를 위한 새로운 Execution context 를 생성후 Execution Stack 에 삽입 a() 함수 내부 로직을 실행한다 (in Execution context of a() ) 그러다 새로운 함수 호출 b() 를 만나면, b()를 위한 새로운 Execution contex를 생성, 같은 과정 반복 각 함수 실행이 끝나는 순서대로 Execution stack 에서 빼내는 순으로 작동이 종료된다 즉, 함수가 호출되어 실행 될 때마다 새로운 execution context가 생성되고, Execution stack 에 삽입, 함수 내부로직을 실행한 뒤에는 Execution stack 에서 빠지고 해당 Execution context 도 사라진다. 그 다음 해당 함수 호출 이후의 코드들이 순차적으로 실행되는 식으로 작동한다. 다음 코드의 실행순서를 살펴보면, a() 호출 (컨텍스트 생성, 스택 삽입) b() 호출 (컨텍스트 생성, 스택 삽입) var d b() out (컨텍스트 삭제, 스택에서 out) var c a() out (컨텍스트 삭제, 스택에서 out) var d 순으로 진행 될 것이다. Variable Environment 각 함수가 호출될때마다 새로운 Execution context 가 추가되고, 변수 myVar는 각각의 Execution context 내에 독립적으로 존재, 각기 다른 메모리공간에 할당된다. 12345678910111213141516171819function b() &#123; var myVar; console.log(myVar);&#125;function a() &#123; var myVar = 2; console.log(myVar); b(); &#125;var myVar = 1;console.log(myVar);a();console.log(myVar);//1//2//undefined//1 변수는 결국 어떤 Execution context 내의 variable environment 속해있는가 에 따라 결정되고 이는 곧 스코프(scope) 개념으로 연결된다. Scope Chain함수가 호출될 때 자바스크립트 엔진은 해당 함수가 ‘’어디” 에 작성됐는지를 기반으로 해당 Execution context의 outer environment 에 대한 reference 를 생성한다. 자기가 속한 Execution context 에서 해당 변수를 찾지 못했다면, outer environment reference 가 가르키는 Execution context 에서 다시 해당 변수를 검색하고.. 그 끝은 결국 전역, Globla Execution context 까지 이른다. 123456789101112function b() &#123; console.log(myVar);&#125;function a() &#123; var myVar = 2; b();&#125;var myVar = 1;a();//1 b() Execution context 에는 변수 myVar 가 없다. 따라서 outer environment 인 Global Execution context 에서 myVar=1 확인 console.log(myVar) ==&gt; 1 1234567891011function a() &#123; function b() &#123; console.log(myVar); &#125; var myVar = 2; b();&#125;var myVar = 1;a(); 위의 코드의 경우 Outer environment 는 b() ==&gt; a() ==&gt; Global execution 순으로 Scope chain 이 결정 될 것이다. 따라서 해당 함수가 어느 Execution context에 정의 되었는지 확인하면 (코드 내 어디에서 선언되었는지) scope chain을 확인 할 수있다. Asynchronous Callback자바스크립트는 동기식 (한번에 하나의 작업처리 순서대로). 동시에 여러개 처리 못함, 자바스크립트는 코드 한줄 한줄 순서대로 실행! 자바스크립트 엔진에는 Execution stack 외에 여러 이벤트들을 담는 Event queue 가 존재한다. 자바스크립트 엔진은 Event queue 를 계속 주시하고 있고, Execution stack이 빈상태가 됐을 때 (순차적으로 실행할 함수들이 다 실행되고 나면) , queue에 있는 이벤트가 발동되면 해당 이벤트의 콜백함수 ( ex) click , clickHandler() ) 를 Execution stack 으로 삽입시켜 함수를 실행하게 한다. ​ 1234567891011121314151617181920// 3초가 지나면 종료되는 함수function waitThreeSeconds() &#123; var ms = 3000 + new Date().getTime(); while (new Date() &lt; ms) &#123;&#125; console.log(&apos;finished function&apos;);&#125;function clickHandler() &#123; console.log(&apos;click event!&apos;);&#125;// 웹페이지 아무대나 클릭하면 발동되도록 리스너 추가document.addEventListener(&apos;click&apos;, clickHandler);waitThreeSeconds();console.log(&apos;finished execution&apos;);//3초 이전에 클릭이벤트를 발생시켜도 결과는 아래와 같다//finished function//finished execution//click event! 위의 코드실행 결과가 왜 저 순서대로 나오는지 이해가 되는가? waitThreeSeconds() 는 3초가 지나면 실행을 종료한다 ( Execution context 사라짐) -&gt; 한줄한줄 코드를 실행하다 끝에 다다른다 (Global Execution context 사라짐) -&gt; Execution stack 빔 -&gt; 그때서야 event queue 확인 -&gt; 해당 event handler() 실행 즉, 자바스크립트 엔진은 Execution stack 이 비워지기 전까지 event queue를 처리하지 않다가 스택이 비게되면(코드를 순차적으로 다 실행하고 나서야) event queue 내에 준비된 event를 처리한다. 이것이 자바스크립트가 동기식으로 비동기식 작업을 처리하는 방식이다. Related PostsType &amp; Operator","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"<Udemy> Javascript weird parts 시작하기","slug":"jsw main","date":"2019-01-29T02:15:51.000Z","updated":"2019-01-30T13:50:14.453Z","comments":true,"path":"2019/01/29/jsw main/","link":"","permalink":"http://mingguk.github.io/2019/01/29/jsw main/","excerpt":"","text":"자바스크립트 개념정리를 위해 이러저리 자료를 찾던중 발견한 보석같은 강의 (feat. 연쇄할인마) 단순 문법이나 기초 예제 복기가 아닌 이면에 자바스크립트가 어떻게 동작하는지 그 원리를(weird parts) 이해하는 것을 목표로 하고 있다. 굳이 왜 작동원리까지..? 라고 생각 할 수 있겠지만 원리에 대한 이해를 바탕으로 더 나은 코드를 작성할 수 있다는 주장이다. 1console.log(&apos;Hello World&apos;); //Hello World 예를들어 Hello world 를 출력하기 위한 이 간단한 코드 이면에, 이를 실행하기 위해 자바스크립트엔진이 어떻게 동작하여 브라우저를 통해 화면에 글자를 출력하게 되는지 같은.. 사실 codestates pre 과정에서 처음하는 javascript임에도 큰 혼란을 겪지않았던건 먼저 이 강의를 수강하고 간 덕분인것 같다. 프론트엔드 개발에 흔히 쓰이는 프레임워크, 라이브러리들도 결국 자바스크립트 코드일뿐 이라는 것, 프론트엔드 개발을 잘하고 싶다, 코드 퀄리티를 높히고 싶다면? 결국 모든것의 기반이 되는 자바스크립트를 깊게 파고 공부하는 것이 최선의 방법 pre course 공부한 내용이랑 자바스크립트 개념 정리를 위해서 시리즈로 블로그에 정리 포스팅을 연재 할 계획이다 그다음은 오래전 결제하고 조금보다 방치한 web bootcamp 랑 javascript real projects 를 완강하고.. Related PostsJSW context &amp; scope","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"},{"name":"weirdparts","slug":"weirdparts","permalink":"http://mingguk.github.io/tags/weirdparts/"}]},{"title":"back","slug":"back","date":"2019-01-28T16:22:52.000Z","updated":"2019-01-30T13:51:14.386Z","comments":true,"path":"2019/01/29/back/","link":"","permalink":"http://mingguk.github.io/2019/01/29/back/","excerpt":"","text":"백엔드 카테고리 Related Posts","categories":[{"name":"Back","slug":"Back","permalink":"http://mingguk.github.io/categories/Back/"}],"tags":[{"name":"back","slug":"back","permalink":"http://mingguk.github.io/tags/back/"}]},{"title":"review","slug":"review","date":"2019-01-28T16:11:57.000Z","updated":"2019-01-30T13:51:04.047Z","comments":true,"path":"2019/01/29/review/","link":"","permalink":"http://mingguk.github.io/2019/01/29/review/","excerpt":"","text":"안녕하세요주로 온라인 강의 나 부트캠프로 공부를 많이 해왔기 때문에 (영어 자료 위주) 필요한 인강의나 강의 선택 시 제 경험이 작은 도움이 됏으면 합니다 주로 강의를 듣는 사이트 Udemy Udacity 인프런 칸아카데미, 코드리뷰 Related post코드스테이츠 pre course 후기","categories":[{"name":"Review","slug":"Review","permalink":"http://mingguk.github.io/categories/Review/"}],"tags":[{"name":"review","slug":"review","permalink":"http://mingguk.github.io/tags/review/"}]},{"title":"코드스테이츠 pre course 후기","slug":"codestates","date":"2019-01-27T21:48:43.000Z","updated":"2019-01-29T08:08:12.393Z","comments":true,"path":"2019/01/28/codestates/","link":"","permalink":"http://mingguk.github.io/2019/01/28/codestates/","excerpt":"","text":"아재, 비전공, 수포자 프로그래밍 도전기 3관 타이틀로 과연 개발자가 될 수 있을까?우연히 관심갖게 된 코딩, 온라인강의나 독학을 전전하며 큰 성과없이 있다, 문득 더 늦기 전에 도전해봐야겠다는 생각에 시작한 code states pre course, 시작한지 어느덧 벌써 한달이 지나갔다.지난 한달간 대부분의 시간과 노력을 투자 했음에도 시작 단계라고 만만히 봤던 pre course는 생각보다 훨씬 ‘빡세고’ ,‘외로운’ 과정이었다 티칭 이 아니라 ‘코칭?’ 솔직히 처음엔 코드스테이츠 측에서 딱히 가르쳐 주는 거 없이 너무 날로(?) 하는거 아닌가라는 불만도 있었다 수업이나 강의를 통해 지식을 전달 받고, pair programming 을 통해 거 의견을 공유하면서 같이 코딩을 하는 시간도 있었다 하지만. 대부분은 부여받은 과제를 해결하기 위해 홀로 이리저리 머리를 짜내고 시도하고, 필요한 부분들을 검색해서 다른 방식으로 접근해보는 식의 연속이었다 시작할때는 뭘 하라는건지 감조차 못잡던 문제들을 직접 부딪혀쳐가며 하나하나 해결해 나가는 과정속에서 나도 모르게 sudo code를 끄적거리고, 내가 생각한 기능을 지원하는 메소드가 있는지 , 이걸 해결하기 위해 내가 모르는게 뭔지, 뭘 공부해야 되는지 검색하고 다시 시도해보는 식의 습관이 자리잡은 것 같다 해결한 과제가 하나 둘 쌓여 갈수록 점점 코드 스테이츠의 방식에 대한 확신이 강해졌다 결국 문제해결능력 아직 잘 모르지만, 지인들이나 회사에서 간접적으로 경험했던 개발자들의 모습, 그리고 pre course 를 진행하면서 느낀 것들을 종합해 보자면 결국 개발자의 실력이란 현장에서 직면하는 문제들을 이미 알고 있는 지식으로, 혹은 모르지만 필요한 것들을 빠르게 습득, 적용하여 효율적으로 문제를 해결하는 것 아닐까? 한가지 덧붙이자면 상용 어플리케이션의 규모상 혼자가 아닌 ‘함께 문제를 잘 해결 해내는 능력’ 까지 ‘코칭’ 측면에서 codestates 의 가치? 나는 무엇인가를 배울 때 가장 중요한 것은 ‘내가 뭘 모르는지 정확히 아는것’ 이라고 생각한다 거기서 명확한 계획과 전략이 나오고 노력이 뒷받침 된다면 성공 할 수 있다고 믿는다 비싼 돈 들여 원어민 강사있는 학원에 가도 영어를 유창하게 배울 확률은 매우 낮다 그 원어민 강사들을 당신이 영어의 어떤 부분을 모르고 부족해서 영어가 안되는지 알지 못한다 (혹은 돈이 안되기 때문에 알면서 외면하거나) 코칭은 대상의 현재 상태와 목표간의 괴리를 객관적으로 파악하고 목표달성을 위한 명확한 방향과 방법을 제시, 서포팅 하는 역할이다 질의응답이나, pre course 러닝코드 프로그램을 진행하면서 코드스테이츠는 수강생들이 뭘 모르고 어려워하는지, 어떤식으로 도와줘야 되는지 잘 안다는 느낌을 받았다아마 과정을 설계한 엔지니어와 직원들 중 다수가 이전에 codestates 과정들을 이수했기 때문이라고 생각된다 나 포함 비전공, 생에 첫 코딩, 무관심자들을 진짜 제대로된 개발자로 만들어내기 위해 코드스테이츠가 제시하는 솔루션은 결국 개발자의 본질, ‘문제해결능력’을 키울 수 있도록 잘 유도하는 하는 것 같다 잘 짜여진 시스템과 단계별로 적당히 도전적 난이도로 설계된 과제들로 이끌어 주고, 개발에 집중 할 수 있는 환경조성, 질의응답, 서포트 역할 등..개인적으로 기대 이상 이었고 충분히 만족스러웠다 이러한 강점들은 정해진 가이드라인이 있는 pre course 보다 각자 프로젝트를 기획, 설계부터 구현까지 스스로 해내야 하는 immersive course 에서 더 빛을 발하지 않을까 생각된다 pre course를 잘 마무리하고 다음 과정인 immersive course 을 통해 제대로 된 개발자로의 커리어 전환에 진지하게 도전해 볼 생각이다 그동안 주입식, 강의식에 질리고 만족스러운 결과를 얻지 못했다면, 개발을 어떻게 배워야되는지 감을 잡지 못했다면 codestates 를 추천하고 싶다물론 훨씬 고된길이 되겠지만.. 기타사항들 학습 환경이 좋다. 성수 패스트파이브 건물 6층 전체, 나머지 층 공유하는거 같은데 오프라인 수강이면 자습환경도 제공한다 (편한자리, 모니터 지원, 5층 카페테리아 공간에서 커피, 음료, 에일맥주 무료 제공) 코딩 외에 다른 지원에도 신경 많이 쓰는거 같다 (면접,이력서,협상 등 커리어 관련 / 수강료 부담 관련 we-win제도 / 생활관련 / 학습환경 조성 등 ) 빠른 피드백(온라인 채널) 최애 성수족발이랑 가깝다.. Related Postshttps://www.codestates.com/ https://mingguk.github.io","categories":[{"name":"Review","slug":"Review","permalink":"http://mingguk.github.io/categories/Review/"},{"name":"Bootcamp","slug":"Review/Bootcamp","permalink":"http://mingguk.github.io/categories/Review/Bootcamp/"}],"tags":[{"name":"codestates","slug":"codestates","permalink":"http://mingguk.github.io/tags/codestates/"},{"name":"코드스테이츠","slug":"코드스테이츠","permalink":"http://mingguk.github.io/tags/코드스테이츠/"}]},{"title":"third post","slug":"third-post","date":"2019-01-27T21:29:17.000Z","updated":"2019-01-30T13:49:58.481Z","comments":true,"path":"2019/01/28/third-post/","link":"","permalink":"http://mingguk.github.io/2019/01/28/third-post/","excerpt":"","text":"html css 도 해야제 카테고리 나누는거 왜케 어렵니.. Related Posts","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"html css","slug":"Front/html-css","permalink":"http://mingguk.github.io/categories/Front/html-css/"}],"tags":[{"name":"html","slug":"html","permalink":"http://mingguk.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"http://mingguk.github.io/tags/css/"}]},{"title":"second post","slug":"second-post","date":"2019-01-27T21:20:23.000Z","updated":"2019-01-30T13:49:46.614Z","comments":true,"path":"2019/01/28/second-post/","link":"","permalink":"http://mingguk.github.io/2019/01/28/second-post/","excerpt":"","text":"카테고리 나누는게이렇게 힘들다니.. Related PostsJavascript 시리즈 1: 시작하기","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"}]},{"title":"first post","slug":"first-post","date":"2019-01-27T21:20:23.000Z","updated":"2019-01-30T13:49:35.522Z","comments":true,"path":"2019/01/28/first-post/","link":"","permalink":"http://mingguk.github.io/2019/01/28/first-post/","excerpt":"","text":"처음이라니헥소 블로그 세팅 헬.. Related PostsJavascript 시리즈 2: 자바스크립트 엔진","categories":[{"name":"Front","slug":"Front","permalink":"http://mingguk.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"http://mingguk.github.io/categories/Front/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mingguk.github.io/tags/javascript/"}]}]}