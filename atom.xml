<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingguk</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingguk.github.io/"/>
  <updated>2019-02-02T12:21:42.782Z</updated>
  <id>http://mingguk.github.io/</id>
  
  <author>
    <name>minkuk Seo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Closure part2</title>
    <link href="http://mingguk.github.io/2019/02/03/Closure2/"/>
    <id>http://mingguk.github.io/2019/02/03/Closure2/</id>
    <published>2019-02-02T18:43:06.000Z</published>
    <updated>2019-02-02T12:21:42.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/Users/seomingug/mingguk/mingguk/source/_posts/jsw closure2.png" alt="jsw closure2"></p><p>공장에서 정해진 포멧에 따라 제품들을 생산하는 것처럼 <strong>팩토리패턴</strong>은 전체 로직을 담은 팩토리함수를 생성, 클로저를 활용해서 반복되는 인자를 기본값으로 하는 함수를 재정의 하고, 호출하는 방식이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// factory function</span><br><span class="line">function makeGreeting(language) &#123;</span><br><span class="line">    return function(firstname, lastname) &#123;</span><br><span class="line">        </span><br><span class="line">        //inside function</span><br><span class="line">        if (language === &apos;en&apos;) &#123;</span><br><span class="line">            console.log(&apos;Hello &apos; + firstname + &apos; &apos; + lastname);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        if (language === &apos;es&apos;) &#123;</span><br><span class="line">            console.log(&apos;Hola &apos; + firstname + &apos; &apos; + lastname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 매번 호출마다 새로운 execution context 생성</span><br><span class="line">var greetEnglish = makeGreeting(&apos;en&apos;);</span><br><span class="line">var greetSpanish = makeGreeting(&apos;es&apos;);</span><br><span class="line"></span><br><span class="line">// 직접 language 접근못하지만, 사용하는 함수</span><br><span class="line">greetingEnglish(&apos;John&apos;, &apos;Doe&apos;);</span><br><span class="line">greetingSpanish(&apos;John&apos;, &apos;Doe&apos;);</span><br></pre></td></tr></table></figure><p>코드 실행 시 makeGreeting(‘en’) 을 만나면 execution context 를 생성하고 en을 할당한다.</p><p><img src="/Users/seomingug/mingguk/mingguk/source/images/jsw closure2 1.png" alt="jsw closure2 1"></p><p>makeGreeting(‘es’) 동일하게 진행되고, 함수실행이 끝나면 language 만 남게된다.</p><p><img src="/Users/seomingug/mingguk/mingguk/source/images/jsw closure2 2.png" alt="jsw closure2 2"></p><p>그 다음 greetingEnglish(), greetingSpanish() 가 실행되면  각각의 outer environment 에서 language를 참조</p><p><img src="/Users/seomingug/mingguk/mingguk/source/images/jsw closure2 3.png" alt="jsw closure2 4"></p><p>즉, <strong>클로저</strong>를 통해 각각의 langauge를 참조하여 각각의 함수를 실행하고 결과를 출력하게 된다.</p><p><img src="/Users/seomingug/mingguk/mingguk/source/images/jsw closure2 4.png" alt="jsw closure2 4"></p><h3 id="Closure-and-Callback"><a href="#Closure-and-Callback" class="headerlink" title="Closure and Callback"></a>Closure and Callback</h3><p>콜백함수는 다른 함수에 인자로 넘긴 함수로, 다른함수 실행이 끝나면 실행되도록 한 함수이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function sayHiLater() &#123;</span><br><span class="line">   //외부변수 greeting 참조, closure</span><br><span class="line">   var greeting = &apos;Hi&apos;;</span><br><span class="line">    </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(greeting);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHiLater();</span><br><span class="line"></span><br><span class="line">function tellMeWhenDone(callback) &#123;</span><br><span class="line">    var a = 1000;</span><br><span class="line">    var b = 2000;</span><br><span class="line">    </span><br><span class="line">    callback(); // 인자로 넣은 함수</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tellMeWhenDone(function() &#123;</span><br><span class="line">   console.log(&quot;I&apos;m done!&apos;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">tellMeWhenDone(function() &#123;</span><br><span class="line">   alert(&quot;I&apos;m done!&apos;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">tellMeWhenDone(function() &#123;</span><br><span class="line">   console.log(&quot;All done&apos;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>###Related Posts</p><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="">next</a></p><p><a href="http://mingguk.github.io/2019/02/01/Closure/">Closure part1</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/Users/seomingug/mingguk/mingguk/source/_posts/jsw closure2.png&quot; alt=&quot;jsw closure2&quot;&gt;&lt;/p&gt;
&lt;p&gt;공장에서 정해진 포멧에 따라 제품들을 생산하는 것처럼 &lt;stro
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>Closure part1</title>
    <link href="http://mingguk.github.io/2019/02/01/Closure/"/>
    <id>http://mingguk.github.io/2019/02/01/Closure/</id>
    <published>2019-02-01T00:00:10.000Z</published>
    <updated>2019-02-02T09:50:53.467Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jsw closure.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//결과로 함수를 리턴 하는 함수</span><br><span class="line">function greet(whattosay) &#123;</span><br><span class="line">    return function(name) &#123;</span><br><span class="line">        console.log(whattosay + &apos; &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;Hi&apos;)(&apos;Tony&apos;);</span><br><span class="line">//Hi Tony</span><br><span class="line"></span><br><span class="line">// greet() 실행이 끝나면 greet()의 execution context 사라짐</span><br><span class="line">var sayHi = greet(&apos;Hi&apos;); </span><br><span class="line"></span><br><span class="line">// 그럼에도 불구하고 어떻게 sayHi()가 다시 whattosay를 참조 했을까?</span><br><span class="line">sayHi(&apos;Tony&apos;); </span><br><span class="line">//Hi tony</span><br></pre></td></tr></table></figure><h3 id="Closure-클로저"><a href="#Closure-클로저" class="headerlink" title="Closure, 클로저 ?"></a>Closure, 클로저 ?</h3><p><img src="/images/jsw closure 0.png" alt=""></p><p>greet(‘Hi’) 가 실행되면 execution context를 생성하고, whattosay 변수를 생성한다.</p><p><img src="/images/jsw closure 1.png" alt=""></p><p>greet() 코드 실행이 끝나면 greet() 의 execution context 는 삭제되지만 whattosay 는 메모리에 여전히 남아있다.</p><p><img src="/images/jsw closure 2.png" alt=""></p><p>그 다음 sayHi(‘Tony’) 가 실행되면 execution context, name 변수 생성하고 다시 한 번 greet() 의 코드를 실행할 것이다. 그러다 console.log(whattosay + ‘ ‘ + name); 코드를 다시 만나면 sayHi(“Tony”)의         execution context 에서 whattosay 변수를 탐색하고, 없다면 <strong>스코프체인</strong>을 따라 outer environment에서 whattosay를 다시 탐색, 코드를 실행한다.</p><p>greet() 함수가 종료되었음에도 내부의 function(name) { console.log(whattosay + ‘ ‘ + name) }; 은 여전히 외부의 whattosay에 접근할 수 있는 셈이다.</p><p><img src="/images/jsw closure 3.png" alt=""></p><p>다시말해, <strong>외부함수가 종료된 뒤에도 내부함수는 여전히 외부함수의 execution context가 사용한 메모리공간에 접근이 가능하다는 것이다.</strong> 이러한 특성을 <strong>Closure, 클로저</strong>라고 한다. 자바스크립트에서는 이 클로저의 특성을 활용한 패턴이 매우 빈번하게 활용되고 있으니 꼭 그 원리를 이해하고 넘어가자.</p><h3 id="클로저-예제"><a href="#클로저-예제" class="headerlink" title="클로저 예제"></a>클로저 예제</h3><p> 아래의 예제를 살펴보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function buildFunction() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    </span><br><span class="line">    for (var i = 0; i &lt;3; i++) &#123;</span><br><span class="line">        arr.push(</span><br><span class="line">        function() &#123;</span><br><span class="line">                console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = buildFunction();</span><br><span class="line"></span><br><span class="line">fs[0]();</span><br><span class="line">fs[1]();</span><br><span class="line">fs[2]();</span><br><span class="line"></span><br><span class="line">// 3 3 3 (!?!? 왜때문에?)</span><br></pre></td></tr></table></figure><p>코드를 잘 살펴보자</p><p><img src="/images/jsw closure ex2.png" alt=""></p><p>buildFunction() 이 먼저 실행되면 노란색으로 표시한 for문 내부의 로직은 expression 이 아니라 statement기 때문에 실행되진 않고 함수선언 자체가 배열에 각각 삽입 될 것이다.</p><p><img src="/images/jsw closure ex3.png" alt=""></p><p>buildFunction() 실행이 끝나면 exectuion context 는 삭제되지만 <strong>해당 변수들은 메모리에 남아있다.</strong></p><p><img src="/images/jsw closure ex4.png" alt=""></p><p>이후 fs[0,1,2] 함수가 각각 실행되어 내부로직을 실행할 때 클로저 특성에 따라 arr과 i를 참조하게 된다. fs() 를 호출하는 시점에서 i의 값은 3이기 때문에 3번의 실행 <strong>모두 i=3 을 참조</strong> 해서 0,1,2 가 아닌 <strong>3,3,3</strong>을 출력하게 된다.</p><p>###만약 0,1,2를 출력하게 하려면?</p><p><strong>let keyword</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function buildFunction2() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    </span><br><span class="line">    for (var i = 0; i &lt;3; i++) &#123;</span><br><span class="line">    let j = i; //block 내 한정, 함수 호출마다 다른 i 삽입</span><br><span class="line">        arr.push(</span><br><span class="line">        function() &#123;</span><br><span class="line">                console.log(j);</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = buildFunction();</span><br><span class="line"></span><br><span class="line">fs[0]();</span><br><span class="line">fs[1]();</span><br><span class="line">fs[2]();</span><br></pre></td></tr></table></figure><p><strong>IIFE</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function buildFunction3() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    </span><br><span class="line">    for (var i = 0; i &lt;3; i++) &#123;</span><br><span class="line">        arr.push(</span><br><span class="line">        (function(j) &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">                console.log(j);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)(i); </span><br><span class="line">      //IIFE로 각각의 ec 생성, i를 변수j에 저장하면 </span><br><span class="line">      //내부함수 실행마다 closure로 각각의 </span><br><span class="line">      //i값 저장한 변수j에 접근가능 =&gt; 0,1,2</span><br><span class="line">        )</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = buildFunction();</span><br><span class="line"></span><br><span class="line">fs[0]();</span><br><span class="line">fs[1]();</span><br><span class="line">fs[2]();</span><br></pre></td></tr></table></figure><p>각각의 execution context 를 생성하고 그때마다 i를 따로 저장하면 가능한데 ,execution context를 생성하는 유일한 방법은 <strong>함수를 실행하는 것</strong>이다.. -&gt; <strong>IIFE 활용</strong></p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/02/03/Closure2/">Closure part2</a></p><p><a href="http://mingguk.github.io/2019/02/01/IIFE/">IIFE</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jsw closure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>IIFE</title>
    <link href="http://mingguk.github.io/2019/02/01/IIFE/"/>
    <id>http://mingguk.github.io/2019/02/01/IIFE/</id>
    <published>2019-01-31T19:48:00.000Z</published>
    <updated>2019-02-02T09:09:12.441Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jsw IIFE.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//function statement</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">    console.log(&apos;Hello &apos; + name); </span><br><span class="line">&#125;</span><br><span class="line">greet(&apos;John);  //Hello John</span><br><span class="line"></span><br><span class="line">//using a function expression </span><br><span class="line">var greetFunc = function(name) &#123;</span><br><span class="line">    console.log(&apos;Hello &apos; + name);</span><br><span class="line">&#125;;</span><br><span class="line">greetFunc(); //Hello John</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//IIFE 함수 생성 후 바로 실행시킴</span><br><span class="line">var greetFunc = function(name) &#123;</span><br><span class="line">    return &apos;Hello &apos; + name;</span><br><span class="line">&#125;(&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">console.log(greeting); // Hello John</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">3;  //vaild</span><br><span class="line">&apos;I&apos;m a string&apos; //vaild</span><br><span class="line">&#123; name: &apos;John&apos; &#125; //vaild</span><br><span class="line"></span><br><span class="line">//그렇다면 함수는?</span><br><span class="line"></span><br><span class="line">//function statement </span><br><span class="line"></span><br><span class="line">function(name) &#123;</span><br><span class="line">    return &apos;Hello &apos; + name;</span><br><span class="line">&#125;</span><br><span class="line">// function 키워드를 보면 statement라고 인식</span><br><span class="line">// 함수명을 요구하기에 error 발생!</span><br><span class="line"></span><br><span class="line">// statement를 괄호()로 묶으면 expression으로 인식</span><br><span class="line">// 함수 생성과 호출을 동시에, IIFE</span><br><span class="line"></span><br><span class="line">var tom = &apos;Tom&apos;</span><br><span class="line"></span><br><span class="line">(function(name) &#123;</span><br><span class="line">   var greeting = &apos;Inside IIFE: Hello&apos;;</span><br><span class="line">   console.log(greeting + &apos; &apos; + name); </span><br><span class="line">&#125;(tom)); // Inside IIFE: Hello Tom</span><br><span class="line"></span><br><span class="line">//IIFE 구조</span><br><span class="line">(function &#123;...&#125;)();  //괄호 밖</span><br><span class="line">(function &#123;...&#125;()); // 괄호 안, 둘 다 가능</span><br></pre></td></tr></table></figure><hr><h3 id="Why-IIFE"><a href="#Why-IIFE" class="headerlink" title="Why IIFE ?"></a>Why IIFE ?</h3><p><img src="/images/jsw IIFE2.png" alt=""></p><p>IIFE 코드가 실행되면 발생하는 일</p><ol><li>Global Execution context 생성</li><li>IIFE 코드, expression을 만나면 메모리에 () 함수 공간 할당</li><li>코드 끝 호출 () 를 만나면 새로운 Execution context 생성</li><li>IIFE 내 변수들 메모리에 할당 () , <strong>Not to Global Object</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;greet.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//greet.js</span><br><span class="line">var greeting = &apos;Hola&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">(function(name) &#123;</span><br><span class="line">    var greeting = &apos;Hello&apos;;</span><br><span class="line">    console.log(greeting + &apos; &apos; + name);</span><br><span class="line">&#125;)(&apos;John&apos;); //IIFE</span><br><span class="line"></span><br><span class="line">console.log(greeting);</span><br><span class="line"></span><br><span class="line">// Hello John</span><br><span class="line">// Hola</span><br></pre></td></tr></table></figure><p><img src="/images/jsw IIFE3.png" alt=""></p><p>​          <strong>Global 의 greeting 과 IIFE 의 greeting 이 충돌없이 공존</strong></p><p><br></p><hr><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p> IIFE 코드 내 변수들은 전부 IIFE 의 Execution context 내의 variable environment 에 속하기 때문에 전역객체에 영향 안줌, <strong>전역 변수나 다른 execution context 들의 변수들과 충돌 가능성 없음! </strong></p><p>이 때문에 대부분의 <strong>라이브러리나 프레임워크는 IIFE 형식으로 설계</strong> 되어있음</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var global = window;</span><br><span class="line"></span><br><span class="line">(function(global, name) &#123;</span><br><span class="line">    var greeting = &apos;Hello&apos;;</span><br><span class="line">    global.greeting = &apos;Hello global&apos;;</span><br><span class="line">    console.log(greeting + &apos; &apos; + name);</span><br><span class="line">&#125;)(window, &apos;John&apos;); //IIFE</span><br></pre></td></tr></table></figure><p>만약 IIFE 로 <strong>글로벌 객체</strong>에 영향을 주고 싶다면? </p><p>IIFE에 글로벌 객체를 <strong>인자</strong>로 전달해서 조작하면 가능</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/02/01/Closure/">Closure</a></p><p><a href="http://mingguk.github.io/2019/01/31/argument/">arguments &amp; etc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jsw IIFE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weridparts" scheme="http://mingguk.github.io/tags/weridparts/"/>
    
  </entry>
  
  <entry>
    <title>arguments &amp; etc</title>
    <link href="http://mingguk.github.io/2019/01/31/argument/"/>
    <id>http://mingguk.github.io/2019/01/31/argument/</id>
    <published>2019-01-31T13:25:15.000Z</published>
    <updated>2019-01-31T13:31:41.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Array-as-an-Object"><a href="#Array-as-an-Object" class="headerlink" title="Array as an Object"></a>Array as an Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Dynamic typing 때문에 서로 다른 타입 요소로 가질 수 있음</span><br><span class="line">var arr = [</span><br><span class="line">1, </span><br><span class="line">false, </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">       name: &apos;Tony&apos;,</span><br><span class="line">       address: &apos;111 Main St.&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">function(name) &#123;</span><br><span class="line">       var greeting = &apos;Hello &apos;;</span><br><span class="line">       console.log(greeting + name);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;hello&quot;;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">//객체, 함수도 요소로 받을 수 있어 바로 호출도 가능</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line">arr[3](arr[2].name); // Hello Tony</span><br></pre></td></tr></table></figure><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p><img src="/images/jsw arg.png" alt=""></p><p>Execution context 가 생성될 때 variable environmnet, this, outer environment 외에 또 하나의 특별한 키워드가 생성 되는데 바로 <strong>arguments</strong> ,함수들에 넘긴 모든 인자들을 다 담은 객체이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function greet (firstname, lastname, language) &#123;</span><br><span class="line">// default 값 설정</span><br><span class="line">language = language || &apos;en&apos;;</span><br><span class="line"></span><br><span class="line">if (arguments.lenght === 0) &#123;</span><br><span class="line">        console.log(&apos;Missing parameters!&apos;);</span><br><span class="line">        console.log(&apos;--------------&apos;);</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    console.log(firstname);</span><br><span class="line">    cosole.log(lastname);</span><br><span class="line">    console.log(language);</span><br><span class="line">    console.log(arguments) //유사배열,따로 선언안해도 사용가능</span><br><span class="line">    console.log(&apos;arg 0: &apos; + arguments[0]) //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(); // 3개 다 undefined </span><br><span class="line">// 함수 선언 시 설정한 인자들을 다 넘길수 / 일부만 넘길수도 / 안넘길수도 있다</span><br><span class="line">greet(&apos;John&apos;); // John / undefined / undefined</span><br><span class="line">greet(&apos;John&apos;, &apos;Doe&apos;); // John, Doe, undefined</span><br><span class="line">greet(&apos;John&apos;, &apos;Doe&apos;, &apos;es&apos;); // John, Doe, es</span><br></pre></td></tr></table></figure><p>여기서 argumnets 는 <strong>유사배열</strong> 이다. 유사배열은 [] 숫자 key를 가지고, length 속성을 가지지만 실제배열의 메소드들은 사용할 수 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Array.isArray() 로 유사배열여부 판단 가능</span><br><span class="line">var arr = [1,2,3];</span><br><span class="line">Array.isArray(arr); // true</span><br><span class="line"></span><br><span class="line">// 배열처럼 index 접근,length 속성 가짐</span><br><span class="line">function checkArg() &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    console.log(arguments[1]);</span><br><span class="line">&#125;</span><br><span class="line">checkArg(a,b,c); </span><br><span class="line"></span><br><span class="line">// Arguments [a,b,c ..]</span><br><span class="line">// 3</span><br><span class="line">// b</span><br><span class="line"></span><br><span class="line">// call, apply 를 사용 유사배열에 배열의 메소드를 차용할 수 있다. </span><br><span class="line">Array.prototype.slice.call(arguments,1,2);</span><br></pre></td></tr></table></figure><h3 id="Function-overloading"><a href="#Function-overloading" class="headerlink" title="Function overloading"></a>Function overloading</h3><p>다른 프로그래밍 언어들은 오버로딩 (같은 이름, 다른타입or 숫자의 인자를 가진 여러개의 함수 생성 가능) 을 지원한다. 자바스크립트는 오버로딩을 지원하진 않지만 <strong>1급함수</strong> 특성을 활용, 더 유연하게 구현이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstname, lastname, language) &#123;</span><br><span class="line">    language = language || &apos;en&apos;;</span><br><span class="line">    </span><br><span class="line">    if (language === &apos;en&apos;) &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + firstname + &apos; &apos; + lastname);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (language === &apos;es&apos;) &#123;</span><br><span class="line">        console.log(&apos;Hola &apos; + firstname + &apos; &apos; + lastname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 만약 다른 인자를 받는 함수를 만들고 싶다면</span><br><span class="line">// 이런식으로 기존 함수를 활용, 오버로딩처럼 구현 가능</span><br><span class="line">function greetEnglish(firstname, lastname) &#123;</span><br><span class="line">    greet(firstname, lastname, &apos;en&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greetEnglish(firstname, lastname) &#123;</span><br><span class="line">    greet(firstname, lastname, &apos;en&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;John&apos;, &apos;Doe&apos;, &apos;en&apos;); // Hello John Doe</span><br><span class="line">greet(&apos;John&apos;, &apos;Doe&apos;, &apos;es&apos;); // Hola John Doe</span><br></pre></td></tr></table></figure><h3 id="세미콜론-꼭-입력해야될까"><a href="#세미콜론-꼭-입력해야될까" class="headerlink" title="세미콜론( ; ) 꼭 입력해야될까?"></a>세미콜론( ; ) 꼭 입력해야될까?</h3><p>자바스크립트 엔진은 작성한 코드를 한자 한자 syntax parser 를 통해 읽어 코드의 의도를 읽고 문법을 판단해서 코드를 실행시킨다. 이때 자바스크립트 엔진은 세미콜론이 필요하다고 판단되는 위치에 자동으로 추가해준다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getPerson() &#123;</span><br><span class="line">    return //자바스크립트 엔진에 의해 자동으로 ; 추가 됨</span><br><span class="line">    &#123;</span><br><span class="line">    firstname: &apos;Tony&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getPerson()); // undefined</span><br></pre></td></tr></table></figure><p>위의 코드 실행 결과를 객체 {firstname: ‘Tony’} 라고 의도했겠지만 실제 결과는 return 뒤에 ; 콜론이 필요하다는 자바스크립트 엔진의 판단으로 인해 빈값이 리턴되어 undefined 이다. </p><p>이런 의도치 않은 오류를 방지하기 위해 세미콜론은 <strong>명시적</strong>으로 입력하는 습관을 가지자.</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/02/01/IIFE/">IIFE</a></p><p><a href="http://mingguk.github.io/2019/01/31/jsw this/">this</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Array-as-an-Object&quot;&gt;&lt;a href=&quot;#Array-as-an-Object&quot; class=&quot;headerlink&quot; title=&quot;Array as an Object&quot;&gt;&lt;/a&gt;Array as an Object&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://mingguk.github.io/2019/01/31/jsw%20this/"/>
    <id>http://mingguk.github.io/2019/01/31/jsw this/</id>
    <published>2019-01-31T02:09:19.000Z</published>
    <updated>2019-01-31T12:53:54.498Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jswThis.png" alt=""></p><p>자바스크립트에서 함수가 실행될 때마다 새로운 Execution context를 생성하고 각 Execution context 는  variable Environmnet, Outer Environment 그리고 <strong>this</strong> 를 생성한다.                                                                                         this 는 함수의 위치, 호출되는 방식에 따라 특정 객체를 가르키게 된다.   </p><p><strong>5 cases of this</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 1. 전역 호출 시 - 전역객체</span><br><span class="line">console.log(this);  // Window &#123;...&#125;</span><br><span class="line"></span><br><span class="line">//2. 함수 내 일반 호출 시 - 전역객체</span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    this.newVariable = &apos;hello&apos;;  //전역객체(Window) 에 새 함수 할당</span><br><span class="line">&#125;</span><br><span class="line">a(); // window &#123;...&#125;</span><br><span class="line">this.newVariable; // hello</span><br><span class="line"></span><br><span class="line">//3. 메소드(객체 내 함수) 호출 시 - 메소드 포함하는 객체</span><br><span class="line">var c = &#123;</span><br><span class="line">    name: &apos;The c object&apos;,</span><br><span class="line">    log: function() &#123;</span><br><span class="line">    this.name = &apos;Updated c object&apos;;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//4. new keyword - 인스턴스(new 키워드로 생성한) 객체</span><br><span class="line">function person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">var tom  = new Person(&apos;Tom&apos;);</span><br><span class="line"></span><br><span class="line">console.log(tom.name); // Tom</span><br><span class="line">console.log(name); // error!</span><br><span class="line"></span><br><span class="line">//5. .call , .apply - 각 함수 첫번째 인자 객체</span><br><span class="line">function speak() &#123;</span><br><span class="line">    var greeting = &apos;Hello i&apos;m + this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">name: &apos;tom&apos;,</span><br><span class="line">age: 18</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">speak.call(person); // tom</span><br><span class="line"></span><br><span class="line">c.log(); // c, Object &#123; name:&apos;Updated c object&apos;, log: function() &#123;console.log(this)&#125;&#125;</span><br><span class="line"></span><br><span class="line">console.log(newVariable); // hello</span><br><span class="line">a();  // Window</span><br></pre></td></tr></table></figure><p><strong>주의할 점 (메소드 내부함수에서 this 호출 시</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;</span><br><span class="line">    name: &apos;The C object&apos;;</span><br><span class="line">    log: function() &#123;</span><br><span class="line">        </span><br><span class="line">        this.name = &apos;Updated c object&apos;;</span><br><span class="line">        console.log(this);</span><br><span class="line">        </span><br><span class="line">        // 메소드의 내부함수의 this는 또 전역을 가르키는 오류 있음</span><br><span class="line">        var setname = function(newName) &#123;</span><br><span class="line">            this.name = newName;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        setName(&apos;Updated again! The c object&apos;);</span><br><span class="line">        console.log(this);ß</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.log();</span><br><span class="line">//오히려 전역객체 name 바뀜, 왜??</span><br><span class="line">window.name = &apos;Updated again! c object&apos;;</span><br><span class="line"></span><br><span class="line">//메소드의 this는 그 객체인데 변경이 안됐다? </span><br><span class="line">// Object &#123;name:&apos;Updated c object&apos;, log: function&#125;</span><br><span class="line">// Object &#123;name:&apos;Updated c object&apos;, log: function&#125;</span><br></pre></td></tr></table></figure><p>메소드의 this는 속해있는 객체를 가르키지만, 또 <strong>메소드 내부 함수는 전역객체를 가르키는 오류가 있다</strong>. 이를 방지하기 위해서는 this를 변수에 명시적으로 지정해주고 그 변수를 활용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;</span><br><span class="line">    name: &apos;The C object&apos;;</span><br><span class="line">    log: function() &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        </span><br><span class="line">        self.name = &apos;Updated c object&apos;;</span><br><span class="line">        console.log(this);</span><br><span class="line">        </span><br><span class="line">        // 메소드의 내부함수의 this는 또 전역을 가르키는 오류 있음</span><br><span class="line">        var setname = function(newName) &#123;</span><br><span class="line">            self.name = newName;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        setName(&apos;Updated again! The c object&apos;);</span><br><span class="line">        console.log(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.log(); // Object &#123;name: &apos;Updated again! The c object&apos;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/31/argument/">arguments &amp; etc</a></p><p><a href="http://mingguk.github.io/2019/01/31/jsw call-by/">call By value &amp; referece</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jswThis.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트에서 함수가 실행될 때마다 새로운 Execution context를 생성하고 각 Execution context 는  variable Environmne
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>call by Value by Reference</title>
    <link href="http://mingguk.github.io/2019/01/31/jsw%20call-by/"/>
    <id>http://mingguk.github.io/2019/01/31/jsw call-by/</id>
    <published>2019-01-31T01:14:47.000Z</published>
    <updated>2019-01-30T16:58:20.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jsw CallBy.png" alt=""></p><h3 id="by-Value"><a href="#by-Value" class="headerlink" title="by Value"></a>by Value</h3><p><img src="/images/jsw byValue.png" alt=""></p><p>말 그대로 같은 <strong>‘Value, 값’</strong>만 복사하고 각기 <strong>다른 메모리공간</strong>에 저장</p><p>따라서 a 나 b 의 값을 바꾼다고 해도 서로의 <strong>값에 영향을 주지 않는다</strong></p><h3 id="by-Reference"><a href="#by-Reference" class="headerlink" title="by Reference"></a>by Reference</h3><p><img src="/images/jsw byRef.png" alt=""></p><p>메모리 상 해당 객체의 주소, reference를 복사하기 때문에 각기 다른 변수에 할당하더라도 모두 <strong>메모리상 같은 공간</strong>을 가르킨다.(해당 주소의 같은 메모리공간) 따라서 해당 객체를 변경하면 그에 연결된 <strong>모든 변수들이 영향을 받음</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//by Value (primitives)</span><br><span class="line">var a = 3;</span><br><span class="line">var b;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">console.log(a);  // 2</span><br><span class="line">console.log(b); // 3</span><br><span class="line"></span><br><span class="line">//by Reference (Objects including functions)</span><br><span class="line">var c = &#123; greeting: &apos;hi&#125;;</span><br><span class="line">var d;</span><br><span class="line"></span><br><span class="line">// 객체이니 새로운 메모리 공간 할당x</span><br><span class="line">//c 가 가르키는 메모리상 같은 공간을 d도 가르키도록 함</span><br><span class="line">d = c; </span><br><span class="line"></span><br><span class="line">c.greeting = &apos;hello&apos;; // mutate</span><br><span class="line"></span><br><span class="line">// 같은 주소상 같은 객체를 변경했기 때문에 둘다 영향 받음</span><br><span class="line">console.log(c);   // Object &#123; greeting: &apos;hello&apos;&#125;</span><br><span class="line">console.log(d); // Object &#123; greeting: &apos;hello&apos;&#125;</span><br><span class="line"></span><br><span class="line">//by Reference (even as parameters)</span><br><span class="line">function changeGreeting(obj) &#123;</span><br><span class="line">    obj.greeting = &apos;Hola!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeGreeting(d);</span><br><span class="line">console.log(c);    // Object &#123; greeting: &apos;Hola!&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>주의 할 점</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// = 연산자를 사용하면 새로운 메모리공간을 할당한다</span><br><span class="line">c = &#123;greeting: &apos;howdy&apos;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(c); // Object &#123; greeting: &apos;howdy&apos;&#125;</span><br><span class="line">console.log(d);   Object &#123; greeting: &apos;Hola!&apos;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/31/jsw Functions/">Functions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jsw CallBy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;by-Value&quot;&gt;&lt;a href=&quot;#by-Value&quot; class=&quot;headerlink&quot; title=&quot;by Value&quot;&gt;&lt;/a&gt;by Value&lt;/h3&gt;
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>Functions</title>
    <link href="http://mingguk.github.io/2019/01/31/jsw%20Functions/"/>
    <id>http://mingguk.github.io/2019/01/31/jsw Functions/</id>
    <published>2019-01-30T22:45:11.000Z</published>
    <updated>2019-01-30T17:14:32.683Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jsw Function.png" alt=""></p><p>자바스크립트에서 function, 함수는 특별한 property를 가진 <strong>객체</strong>이다. </p><p><strong>name</strong> : Optional, 익명도 가능 작성한 코드의 Reference </p><p><strong>code</strong> : 작성한 코드, invocable() 이라는 작성한 코드를 실행시키는 특성을 가지고 있다.</p><p>이 두가지 property를 통해 자바스크립트에서 함수는 <strong>다른 변수나 객체가 하는 모든 역할들을 수행할 수 있다.</strong> (<strong>First Class Function, 1급 함수</strong>)  뒤에 나올 함수형 프로그래밍도 이 함수를 다른 함수의 인자로 넘길 수 있는 특성을 활용한 프로그래밍 기법의 일환이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;</span><br><span class="line">    console.log(&apos;hi&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 함수는 객체이기 때문에 . 연산자 사용이 가능하다</span><br><span class="line">greet.language = &apos;english&apos;;</span><br><span class="line"></span><br><span class="line">console.log(greet.language); //english</span><br></pre></td></tr></table></figure><p><br></p><p><img src="/images/jsw%20FO.png" alt=""></p><p>위와 같이 함수를 생성하면 다른 객체처럼 메모리에 저장되고 이 함수는 <strong>NAME 과 CODE</strong> 를 가지기 때문에 이 함수를 호출  greet() 하면 작성한 코드를 invocable() 통해 실행 하게 된다.</p><p>아래의 코드를 확인해보자</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function log(a) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;a&apos;); // a</span><br><span class="line">log(3); // 3</span><br><span class="line">log(&#123;greeting:&apos;hi&apos;&#125;) // Object &#123;greeting: &apos;hi&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 함수가 객체이기에 인자로 넣을 수 있음</span><br><span class="line">log(function() &#123;</span><br><span class="line">    console.log(&apos;Hello&apos;);   // function() &#123;console.log(&apos;hi&apos;)&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>만약 코드 마지막 줄에 인자로 넣은 함수를 실행한 결과값을 얻고 싶다면?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// log 함수를 인자를 호출하는 식으로 변경</span><br><span class="line">function log(a) &#123;</span><br><span class="line">    a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(function() &#123;</span><br><span class="line">   console.log(&apos;hi&apos;);   // hi </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Function-statements-amp-Expressions"><a href="#Function-statements-amp-Expressions" class="headerlink" title="Function statements &amp; Expressions"></a>Function statements &amp; Expressions</h3><p>자바스크립트에서 <strong>expression</strong>란 특정 <strong>value</strong>를 리턴하는 코드를 말한다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//expressions</span><br><span class="line">a = 3 // 3</span><br><span class="line">1 + 2; // 3</span><br><span class="line">a = &#123; greeting: &apos;hi&apos;&#125; // Object &#123;greeting: &apos;hi&apos;&#125;</span><br></pre></td></tr></table></figure><p>반면에 <strong>statement</strong> 란 리턴이 없는 코드를 의미한다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//statement</span><br><span class="line">function greet() &#123;</span><br><span class="line">    console.log(&apos;hi&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Anonymous Function</strong></p><p><img src="/images/jsw anonymous.png" alt=""></p><p>익명함수는 이름이 없는 함수를 의미한다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// anonymous function, 이경우에는 익명함수가 Object를 반환</span><br><span class="line">// 변수에 할당하기에 expression 이라고 볼 수 있음</span><br><span class="line">var anonymousGreet = function() &#123;</span><br><span class="line">    console.log(&apos;hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 할당한 변수명 + () 통해 호출 할 수 있다</span><br><span class="line">anonymousGreet();</span><br></pre></td></tr></table></figure><p>아래코드의 실행결과를 살펴보자</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">greet();</span><br><span class="line"></span><br><span class="line">//Hoisting 에 의해 함수는 미리 메모리에 셋업되기 때문에 hi 출력 </span><br><span class="line">function greet() &#123;</span><br><span class="line">    console.log(&apos;hi&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 변수에 할당 되었기에 현재 undefined </span><br><span class="line">anonymousGreet();</span><br><span class="line"></span><br><span class="line">var anonymousGreet = function() &#123;</span><br><span class="line">    console.log(&apos;hi&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// hi</span><br><span class="line">//uncaught type error, undefined is not a function...</span><br></pre></td></tr></table></figure><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/31/jsw call-by/">call By value &amp; referece</a></p><p><a href="http://mingguk.github.io/2019/01/31/jsw Object/">Object</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jsw Function.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트에서 function, 함수는 특별한 property를 가진 &lt;strong&gt;객체&lt;/strong&gt;이다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;name&lt;/s
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>Object</title>
    <link href="http://mingguk.github.io/2019/01/31/jsw%20Object/"/>
    <id>http://mingguk.github.io/2019/01/31/jsw Object/</id>
    <published>2019-01-30T16:34:53.000Z</published>
    <updated>2019-01-30T17:07:00.029Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jswOF.png" alt=""></p><h3 id="Object-in-javascript"><a href="#Object-in-javascript" class="headerlink" title="Object in javascript"></a>Object in javascript</h3><p><img src="/images/jswObject.png" alt=""></p><p>자바스크립트에서 객체는 <strong>a collection of key value pairs</strong>  이다.</p><p>객체의 요소로 변수, 함수(메소드), 심지어 다른 객체 까지 가질 수 있고 각각의 요소에 대한 reference(메모리 어디에 저장되어있는지, 주소) 를 가지고 있다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line"></span><br><span class="line">// [] 는 연산자, 해당 객체의 name 주소로 가서 value 를 반환하는</span><br><span class="line">person[&apos;firstname&apos;] = &apos;minkuk&apos;;  // name value pair</span><br><span class="line"></span><br><span class="line">// firstname 의 reference를 객체 person에게 부여</span><br><span class="line">person[&apos;lastname&apos;] = &apos;Seo&apos;;</span><br><span class="line"></span><br><span class="line">var firstNameProperty = &apos;firstname&apos;;</span><br><span class="line"></span><br><span class="line">console.log(person); //Object</span><br><span class="line">console.log(person[firstNameProperty]); //Tony</span><br><span class="line"></span><br><span class="line">// . 또한 연산자  a.name --&gt; a 객체의 name 의 value에 접근가능</span><br><span class="line">console.log(person.firstname); //Tony</span><br><span class="line"></span><br><span class="line">//객체 내 요소 추가하기</span><br><span class="line">person.address = new Object();</span><br><span class="line">person.address.street = &apos;111 Main St.&apos;;</span><br><span class="line">person.address.city = &apos;New York&apos;;</span><br><span class="line">person.address.state = &apos;NY&apos;;</span><br><span class="line"></span><br><span class="line">//. 연산자로 객체의 요소들에 접근, 참조가능</span><br><span class="line"></span><br><span class="line">console.log(person.address.street) // 111 Main St.</span><br><span class="line">console.log(person.address.city) // New York</span><br><span class="line">console.log(person[&apos;address&apos;][&apos;state&apos;]) // NY</span><br></pre></td></tr></table></figure><h3 id="Object-literals"><a href="#Object-literals" class="headerlink" title="Object literals"></a>Object literals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;; // 객체 생성 </span><br><span class="line">var person = &#123;</span><br><span class="line">firstname: &apos;minkuk&apos;,</span><br><span class="line">    lastname: &apos;Seo&apos;</span><br><span class="line">    </span><br><span class="line">   //다른 객체도 객체의 요소로 생성가능</span><br><span class="line">   address: &#123;</span><br><span class="line">        street: &apos;111 Main St.&apos;,</span><br><span class="line">        city: &apos;New York&apos;,</span><br><span class="line">        state: &apos;NY&apos;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">//객체는 함수의 인자로도 전달이 가능하다</span><br><span class="line">function greet(person) &#123;</span><br><span class="line">    console.log(&apos;Hi &apos; + person.firstname);</span><br><span class="line">&#125;</span><br><span class="line">greet(Tony); // Hi Tony</span><br><span class="line"></span><br><span class="line">// 이런식으로 객체생성과 동시에 인자로 넘기기도 가능</span><br><span class="line">greet(&#123;</span><br><span class="line">    firstname: &apos;Mary&apos;,</span><br><span class="line">    lastname: Doe</span><br><span class="line">&#125;); // Hi Mary Doe</span><br></pre></td></tr></table></figure><h3 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var greet = &apos;Hello!&apos;;</span><br><span class="line">var greet = &apos;Hola!&apos;;</span><br><span class="line"></span><br><span class="line">console.log(greet); </span><br><span class="line">// Hola!</span><br></pre></td></tr></table></figure><p>자바스크립트는 순차적으로 코드를 실행하기 때문에 위의 결과를 예측하기는 쉽다.</p><p>하지만 만약에 각 변수가 다른 자바스크립트에 저장되어 있거나, 외부에서 라이브러리로 가져다 쓰는거라면? 의도치 않게 같은 변수명으로 인해 충돌 가능성이 있다.</p><p><img src="/images/jswNameSpace.png" alt=""></p><p>이러한 충돌을 방지하기 위해 Namespace 개념이 발생했다. 자바스크립트에서는 객체를 이 네임스페이스로 활용 할 수 있다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var english = &#123;greet: &apos;Hello!&apos;&#125;;</span><br><span class="line">var spanish = &#123;greet: &apos;Hola!&apos;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(english.greet); //Hello!</span><br><span class="line">console.log(spanish.greet); //Hola!</span><br></pre></td></tr></table></figure><p><strong>객체 요소 추가 시 주의사항</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">english.greeting.greet = &apos;Hi!&apos;;  //이런 식은 error 발생</span><br><span class="line">//. 연산자의 우선순위에 따라 (연관 left-to-right)</span><br><span class="line">//english.greeting은 undefined가 이기 때문에</span><br><span class="line"></span><br><span class="line">// 객체 내 새로운 요소를 생성할 때는 [] 연산자를 사용하거나</span><br><span class="line">english[greeting][greet] = &apos;Hi!&apos;;</span><br><span class="line"></span><br><span class="line">// 객체 생성과 동시에 요소를 추가하는 것을 추천</span><br><span class="line">english = &#123;greeting: &#123;greet:&apos;Hi!&apos;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(english.greeting.greet); // Hi!</span><br></pre></td></tr></table></figure><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/31/jsw Functions/">Functions</a></p><p><a href="http://mingguk.github.io/2019/01/30/jsw type&amp;operator/">Type &amp; Operator</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jswOF.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Object-in-javascript&quot;&gt;&lt;a href=&quot;#Object-in-javascript&quot; class=&quot;headerlink&quot; title=&quot;Object i
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>type &amp; operator</title>
    <link href="http://mingguk.github.io/2019/01/30/jsw%20type&amp;operator/"/>
    <id>http://mingguk.github.io/2019/01/30/jsw type&amp;operator/</id>
    <published>2019-01-30T13:26:41.000Z</published>
    <updated>2019-01-30T17:05:16.886Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jswTO.png" alt=""></p><h3 id="Dynamic-typing"><a href="#Dynamic-typing" class="headerlink" title="Dynamic typing"></a>Dynamic typing</h3><p>자바스크립트는 <strong>동적 타이핑</strong> 을 사용한다. 자바스크립트 엔진이 코드가 실행될 때 자동으로 변수들의 type을 확인함.</p><h3 id="Primitive-types"><a href="#Primitive-types" class="headerlink" title="Primitive types"></a>Primitive types</h3><p>a single value 를 의미</p><p><strong>undefined</strong> (아무것도 없음, 변수에 명시적으로 undefined를 할당하지 말 것)</p><p><strong>null</strong>(아무것도 없음, 명시적으로 null 지정해도 괜찮음)</p><p><strong>Boolean</strong></p><p><strong>Number</strong></p><p><strong>String</strong></p><p><strong>Symbol</strong> (ES6)</p><hr><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>자바스크립트에서 연산자는 조금 특별한 방식으로 쓰여진 <strong>함수</strong>이다 인자들을 받아 하나의 결과값을 내는.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num = 3 + 4;</span><br><span class="line"></span><br><span class="line">+ (3,4);</span><br><span class="line"></span><br><span class="line">// 어딘가에 다른 방식으로 + 라는 function이 정의되어있기에 자바스크립트에서 연산자들 사용가능</span><br><span class="line">function + (a, b) &#123;</span><br><span class="line">    return // add the two numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Operator precedence (우선순위) &amp; Associativity(연관)</strong></p><p><strong>Precedence</strong> - 어떤 연산을 먼저 처리 할 것인가</p><p><strong>Associativity</strong> - 같은 우선순위를 가진 연산자끼리는 어떤걸 먼저 처리 할 것인가?</p><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84#%ED%91%9C" target="_blank" rel="noopener">Javascript 우선순위, 연관 확인</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Precedence example</span><br><span class="line"></span><br><span class="line">var a = 3 + 4 * 5;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">// var a = (4 * 5) + 3 </span><br><span class="line">// 23</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Associativity example</span><br><span class="line"></span><br><span class="line">var a = 2, b = 3, c = 4;</span><br><span class="line"></span><br><span class="line">a = b = c;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br><span class="line"></span><br><span class="line">// assignment(=) 의 연관이 rigth-to-left 이기 때문에</span><br><span class="line">// 1)b = c  2) a = b 순으로 연산, 따라서 결과는</span><br><span class="line">//4 4 4</span><br></pre></td></tr></table></figure><hr><p><strong>coercion</strong></p><p>변수의 타입을 <strong>변형</strong>시키는 것</p><p>자바스크립트는 동적 타이핑 이기때문에 coercion이 빈번하게 발생</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + &apos;2&apos;;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">// &apos;12&apos; coercion 이 자바스크립트 엔진에 의해 자동으로 수행됨</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number(false) // 0</span><br><span class="line">Number(true) // 1</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line">Number(null) // 0</span><br><span class="line"></span><br><span class="line">console.log(3 &lt; 2 &lt; 1); //true  왜!?!?</span><br><span class="line">(연관 left-to-right) 3 &lt; 2 = false =&gt;0 , 0 &lt; 1 = true</span><br></pre></td></tr></table></figure><p>coercion 자동변환으로 편의성도 제공하지만  위의 예제처럼 개발자(사람) 관점에서는 <strong>이해할 수 없는 오류를 발생시킬 가능성 내포,</strong> 주의가 필요함</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">false == 0 // true</span><br><span class="line">null == 0 // false</span><br><span class="line">null &lt; 1 // true</span><br><span class="line"></span><br><span class="line">&quot;&quot; == 0 // true</span><br><span class="line">&quot;&quot; == false // true</span><br><span class="line"></span><br><span class="line">//coercion 은 코드결과 예측을 불확실하게 만들 수 있다. (특히 == 연산자)</span><br><span class="line">//대신 &apos;===&apos;, &apos;!==&apos; 연산자를 사용 할 것 추천</span><br><span class="line"></span><br><span class="line">3 === 3 // true</span><br><span class="line">3 === &apos;3&apos; // false</span><br></pre></td></tr></table></figure><p><strong>Existence &amp; Booleans</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">if (a) // 조건문 () 안에 들어가면 Boolean 으로 coercion 된다</span><br><span class="line">&#123;</span><br><span class="line">   console.log(&apos;Something is there.&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = 0;</span><br><span class="line"></span><br><span class="line">if (a) // Boolean(0) =&gt; false , 0이라는 값이 있음에도 잘못된 결과를 유발, 이때는</span><br><span class="line"></span><br><span class="line">if (a || a === 0) &#123;   </span><br><span class="line">console.log(&apos;Something is there.&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// === 연산자 우선순위에 따라 a || true 가되고 || 연산자에 따라</span><br><span class="line">// 그 다음 a || true 를 따지면 최종적으로 괄호안 조건은 true 됨</span><br><span class="line"></span><br><span class="line">//Something is there</span><br></pre></td></tr></table></figure><p><strong>Default Values</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function greet(name) &#123;</span><br><span class="line">// default value 지정하는 법</span><br><span class="line">name = name || &apos;&lt;Your name here&gt;&apos;; </span><br><span class="line">    console.log(&apos;Hello &apos; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;Tony&apos;); //Hello Tony</span><br><span class="line">greet(); // Hello &lt;Your name here&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/31/jsw Object/">Object</a></p><p><a href="http://mingguk.github.io/2019/01/29/jsw context &amp;ex/">Context &amp; Lexical environment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jswTO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Dynamic-typing&quot;&gt;&lt;a href=&quot;#Dynamic-typing&quot; class=&quot;headerlink&quot; title=&quot;Dynamic typing&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>웹개발 공부계획</title>
    <link href="http://mingguk.github.io/2019/01/29/webDev-plan/"/>
    <id>http://mingguk.github.io/2019/01/29/webDev-plan/</id>
    <published>2019-01-29T13:28:27.000Z</published>
    <updated>2019-01-30T17:34:46.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="웹개발-공부-계획"><a href="#웹개발-공부-계획" class="headerlink" title="웹개발 공부 계획"></a>웹개발 공부 계획</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p><img src="/images/nothing.png" alt=""></p><h3 id="References-위주로-큰-틀을-잡고-다른-소스들-참고"><a href="#References-위주로-큰-틀을-잡고-다른-소스들-참고" class="headerlink" title="References (위주로 큰 틀을 잡고 다른 소스들 참고)"></a>References (위주로 큰 틀을 잡고 다른 소스들 참고)</h3><ol><li><a href="https://medium.com/@Jbee_/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EB%A0%A4%EB%A9%B4-%EB%AC%B4%EC%97%87%EC%9D%84-%ED%95%99%EC%8A%B5%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94-1dd59a14e084?fbclid=IwAR2Qwaifz8Lnn_aOF54zPrwdWxwYcI1qO8Xo4-N1uG-QEEaZRWQBbEcrH8Q" target="_blank" rel="noopener">프론트엔드 뭘 공부해야 하는가?</a><br></li><li><a href="https://medium.com/@codesquad_yoda/%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C-5ac7bb6ff2a9" target="_blank" rel="noopener">웹프론트엔드 개발자, 어떻게 준비?</a> <br></li><li><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">Developer roadmap</a> </li></ol><hr><p><strong>1. Javascript</strong></p><p>자바스크립트 동작원리</p><p>자바스크립트 문법, 주요개념</p><p>DOM</p><p>ES6</p><p>자바스크립트 생태계 (npm Web pack / bable)</p><p>CommonJS</p><p>OOP in Javascript / 함수형 프로그래밍</p><p>Type script</p><p>AJAX CORS</p><hr><p><strong>2. HTML / CSS</strong></p><p>grid</p><p>Midea query</p><p>CSS Framework (Bootsctrap 4</p><p>웹 접근성</p><hr><p><strong>3. library framework</strong></p><p>react</p><p>상태관리 라이브러리</p><p>react native</p><hr><p><strong>4. CS , Network, algorithm</strong></p><p>자료구조</p><p>알고리즘 (Udemy, daily toy, 면접대비)</p><hr><p><strong>5. Backend</strong></p><p>서버사이드 / 클라이언트 사이드 렌더링</p><p>node js</p><p>graphQL</p><p>MongoDB</p><hr><p><strong>6. Etc</strong></p><p>Github</p><p>Blogging</p><p>Terminal usage</p><p>Design patterns</p><p>English (업무수준 상회)</p><hr><h3 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h3><p>1월 &lt;기초&gt;&lt;숲 파악&gt;**</p><ol><li>런코 전과정 마스터(발췌,보충) , 테스트 준비, 통과 </li><li>udemy javascript weird parts 정리 (블로깅)</li><li>udemy web dev bootcamp 일부 (런코 관련)</li></ol><p>==&gt;  javascript 기본개념, 사용법 정리</p><p><strong>2월 &lt;프론트엔드&gt; <cs 기초=""></cs></strong></p><ol><li><p>자바스크립트 작동원리, 개념정리, codestates pre course 복습 (블로깅)</p></li><li><p>udemy web dev bootcamp 완강, udemy javascript build real app 완강  (js 로 웹 실제 조작, 구현 경험)</p></li><li><p>udemy algorithm in javascript (자료구조, 원리 이해, 직접 구현)<br>udemy network 이론강의 수강 , 컴원리 포함</p></li><li><p>생태계, javascript 관련 필수 이슈들</p></li><li><p>HTML / CSS (udemy Html/css 강의 / 미디어쿼리)</p></li></ol><p><strong>3월~4.11 &lt;풀스택 경험 + 백엔드 기초&gt; &lt;갈무리&gt;</strong></p><ol><li><p>라이브러리 (react , react native 기초 공부) - udemy / nomad react 기초강의들</p></li><li><p>nomad coder 풀스택 과정 1개 수료 (유튜브 or 우버 or  클론)</p></li><li><p>그동안 공부한 것 정리 (블로그 - TIL ,특수 주1회 / 깃헙) / 알고리즘 지속 공부</p></li></ol><p><strong>4월~ 수료까지 Codetates immersive course </strong><br>목표 : <strong>실력 있는 프론트엔드 개발자 &amp;&amp; 웹개발 커리어 시작 </strong></p><ul><li><p>지속 학습능력 (스스로 배우는 방법 터득, 체화)</p></li><li><p>커뮤니케이션, 협업 능력 (혼자 보다 함께, 더 크게)</p></li><li><p>기본기 갖추기 (cs, 네트워크 / 알고리즘 / 기반 작동원리 파악)</p></li><li><p>full-stack 설계 및 구현 경험  ( front 기반 + backend 기초 구축, 어플리케이션 전체)</p></li><li><p>Web + android + ios (react native)  / backend 통합 결과물 완성하기 </p></li><li><p>포트폴리오 및 브랜딩 ( 깃헙 / 블로그(개발공부, 포트폴리오 페이지 따로) )</p></li></ul><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;웹개발-공부-계획&quot;&gt;&lt;a href=&quot;#웹개발-공부-계획&quot; class=&quot;headerlink&quot; title=&quot;웹개발 공부 계획&quot;&gt;&lt;/a&gt;웹개발 공부 계획&lt;/h3&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="post" scheme="http://mingguk.github.io/categories/post/"/>
    
    
      <category term="plan" scheme="http://mingguk.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>Context &amp; Lexical Environments</title>
    <link href="http://mingguk.github.io/2019/01/29/jsw%20context%20&amp;ex/"/>
    <id>http://mingguk.github.io/2019/01/29/jsw context &amp;ex/</id>
    <published>2019-01-29T03:21:31.000Z</published>
    <updated>2019-01-30T17:03:40.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jswcc.png" alt=""></p><p>자바스크립트를 이해하는데 있어 중요한 기본개념 3가지</p><h3 id="Syntax-parsers"><a href="#Syntax-parsers" class="headerlink" title="Syntax parsers"></a>Syntax parsers</h3><p><img src="/images/jswSP.png" alt=""></p><p>작성한 코드를 컴퓨터가 이해 가능한 언어로 번역, 문법을 확인해주는 프로그램 </p><h3 id="Lexical-environments"><a href="#Lexical-environments" class="headerlink" title="Lexical environments"></a>Lexical environments</h3><p>프로그래밍 언어에서 lexical 이란 특정 단어나 문법과 연관이 있다는 의미로, 코드를 어느 <strong>위치</strong> 에 작성하느냐, 그 코드를 어떤것이 <strong>감싸고 있느냐</strong> 에 따라 전혀 다르게 작동한다는 의미</p><p><img src="/images/jswLexical.png" alt=""></p><p> 예를들어 위의 사진에서 변수 a는 hello 라는 함수 안에 위치하고 있기 때문에 hello() 내에서만 존재, 접근가능</p><h3 id="Execution-context"><a href="#Execution-context" class="headerlink" title="Execution context"></a>Execution context</h3><p><img src="/images/jswEC.png" alt=""></p><p> lexical environments 중에서 어떤 환경을 선택해서 실행되는지를 관리하는 Wrapper 이다.</p><h3 id="Excution-context-Global"><a href="#Excution-context-Global" class="headerlink" title="Excution context (Global)"></a>Excution context (Global)</h3><p><img src="/images/jsw EC.png" alt=""></p><p>자바스크립트 코드를 실행하면 </p><ol><li>Execution context 생성</li><li>Global object(window), this 생성</li><li>Outer environment 생성</li><li>작성한 코드 실행</li></ol><p>순으로 진행된다. 자바스크립트에서 말하는 Global(전역)은 <strong>Not in a function, 특정 객체나 함수가 아님</strong> 을 의미한다 즉, 특정 객채(함수) 안에 <strong>(lexical evironmental)</strong> 존재하지 않는다는 의미</p><hr><h3 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line">var a = &apos;Hello World&apos;;</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&apos;Called b&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br><span class="line">// Called b</span><br><span class="line">// Hello World</span><br></pre></td></tr></table></figure><p>(1) 코드 실행결과를 예측하는 것은 쉬운 일이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(2)</span><br><span class="line">b();</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br><span class="line">var a = &apos;Hello World&apos;;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&apos;Called b&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//called b</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>하지만 (2)는? 변수 a 는 undefined, 함수 b는 정상적으로 출력이 됐다.</p><p>이러한 현상을 호이스팅(Hoisting)이라고 한다. 몇몇 설명에서는 마치 코드를 물리적으로 최상단으로 이동시킨 다는 식인데 이는 오해의 소지가 있다.</p><p>excution context는 두 단계가 있다 <strong>Creation phase</strong> 와 <strong>Excution phase</strong></p><p><strong>Creation phase</strong></p><p>Execution context 가 생성되면 동시에 global object, this, outer environment를 생성하고 변수와 함수 저장을 위해 메모리공간을 먼저 할당한다. 이때 모든 변수는 먼저 <strong>undefined</strong> 로 할당되고 함수는 의도대로 할당되는데 이 과정을 <strong>Hoisting</strong> 이라고 한다.</p><p><strong>Execution phase</strong></p><p>이 모든 작업 이후 코드가 한줄 한줄 순서대로 실행 되면서 의도한 값들이 해당 변수에 할당 됨.</p><hr><h3 id="Function-invokation"><a href="#Function-invokation" class="headerlink" title="Function invokation"></a>Function invokation</h3><p>자바스크립트에서 함수를 호출하면 어떤 일이 벌어질까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><ol><li><p>Global Execution Context , Global Object, this 생성</p></li><li><p>메모리에 함수 a 와 b 를 위한 공간 셋업</p></li><li><p>한줄 한줄 실행하다 함수호출 a() 를 만나면</p></li><li><p>a() 를 위한 새로운 Execution context 를 생성후  Execution Stack 에 삽입</p></li><li><p>a() 함수 내부 로직을 실행한다 (in Execution context of a() )</p></li><li><p>그러다 새로운 함수 호출 b() 를 만나면, b()를 위한 새로운 Execution contex를 생성, 같은 과정 반복</p></li><li><p>각 함수 실행이 끝나는 순서대로 Execution stack 에서 빼내는 순으로 작동이 종료된다</p><p><img src="/images/jswFC.png" alt=""></p></li></ol><p><strong>즉, 함수가 호출되어 실행 될 때마다 새로운 execution context가 생성되고, Execution stack 에 삽입, 함수 내부로직을 실행한 뒤에는 Execution stack 에서 빠지고 해당 Execution context 도 사라진다. 그 다음 해당 함수 호출 이후의 코드들이 순차적으로 실행되는 식으로 작동한다</strong>.</p><p>다음 코드의 실행순서를 살펴보면, </p><p><img src="/images/jswFE.png" alt=""></p><ol><li>a() 호출 (컨텍스트 생성, 스택 삽입)</li><li>b() 호출 (컨텍스트 생성, 스택 삽입) </li><li>var d </li><li>b() out (컨텍스트 삭제, 스택에서 out)</li><li>var c </li><li>a() out (컨텍스트 삭제, 스택에서 out)</li><li>var d </li></ol><p>순으로 진행 될 것이다.</p><hr><h3 id="Variable-Environment"><a href="#Variable-Environment" class="headerlink" title="Variable Environment"></a>Variable Environment</h3><p><img src="/images/jswVE.png" alt=""></p><p>각 함수가 호출될때마다 새로운 Execution context 가 추가되고, 변수 myVar는 각각의 Execution context 내에 <strong>독립적으로 존재,  각기 다른 메모리공간에 할당된다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    var myVar;</span><br><span class="line">    console.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line">function a() &#123;</span><br><span class="line">    var myVar = 2;</span><br><span class="line">    console.log(myVar);</span><br><span class="line">    b();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myVar = 1;</span><br><span class="line">console.log(myVar);</span><br><span class="line">a();</span><br><span class="line">console.log(myVar);</span><br><span class="line"></span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//undefined</span><br><span class="line">//1</span><br></pre></td></tr></table></figure><p>변수는 결국 어떤 Execution context 내의 variable environment 속해있는가 에 따라 결정되고 이는 곧 <strong>스코프(scope)</strong> 개념으로 연결된다.</p><hr><h3 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h3><p>함수가 호출될 때 자바스크립트 엔진은 해당 함수가 <strong>‘’어디”</strong> 에 작성됐는지를 기반으로 해당 Execution context의 outer environment 에 대한 reference 를 생성한다. 자기가 속한 Execution context 에서 해당 변수를 찾지 못했다면, outer environment reference 가 가르키는 Execution context 에서 다시 해당 변수를 검색하고.. 그 끝은 결국 전역, Globla Execution context 까지 이른다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    console.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line">function a() &#123;</span><br><span class="line">    var myVar = 2;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myVar = 1;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">//1</span><br></pre></td></tr></table></figure><ol><li><p>b() Execution context 에는 변수 myVar 가 없다. </p></li><li><p>따라서 outer environment 인 Global Execution context 에서 myVar=1 확인</p></li><li><p>console.log(myVar) ==&gt; 1</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    function b() &#123;</span><br><span class="line">    console.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line">    var myVar = 2;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myVar = 1;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>위의 코드의 경우 Outer environment 는   b() ==&gt; a() ==&gt; Global execution 순으로 Scope chain 이 결정 될 것이다.</p><p><img src="/images/jswSC.png" alt=""></p><p><strong>따라서 해당 함수가 어느 Execution context에 정의 되었는지 확인하면 </strong>(코드 내 어디에서 선언되었는지) <strong>scope chain을 확인 할 수있다</strong>.</p><hr><h3 id="Asynchronous-Callback"><a href="#Asynchronous-Callback" class="headerlink" title="Asynchronous Callback"></a>Asynchronous Callback</h3><p><strong>자바스크립트는 동기식</strong> (한번에 하나의 작업처리 순서대로).</p><p>동시에 여러개 처리 못함, 자바스크립트는 코드 한줄 한줄 순서대로 실행!</p><p><img src="/images/jswAsync.png" alt=""></p><p>자바스크립트 엔진에는 Execution stack 외에  여러 이벤트들을 담는 <strong>Event queue</strong> 가 존재한다.</p><p>자바스크립트 엔진은 Event queue 를 계속 주시하고 있고, Execution stack이 빈상태가 됐을 때 (순차적으로 실행할 함수들이 다 실행되고 나면) , queue에 있는 이벤트가 발동되면 해당 이벤트의 콜백함수 ( ex) click , clickHandler() ) 를 Execution stack 으로 삽입시켜 함수를 실행하게 한다.</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 3초가 지나면 종료되는 함수</span><br><span class="line">function waitThreeSeconds() &#123;</span><br><span class="line">    var ms = 3000 + new Date().getTime();</span><br><span class="line">    while (new Date() &lt; ms) &#123;&#125;</span><br><span class="line">        console.log(&apos;finished function&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function clickHandler() &#123;</span><br><span class="line">    console.log(&apos;click event!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 웹페이지 아무대나 클릭하면 발동되도록 리스너 추가</span><br><span class="line">document.addEventListener(&apos;click&apos;, clickHandler);</span><br><span class="line"></span><br><span class="line">waitThreeSeconds();</span><br><span class="line">console.log(&apos;finished execution&apos;);</span><br><span class="line"></span><br><span class="line">//3초 이전에 클릭이벤트를 발생시켜도 결과는 아래와 같다</span><br><span class="line">//finished function</span><br><span class="line">//finished execution</span><br><span class="line">//click event!</span><br></pre></td></tr></table></figure><p>위의 코드실행 결과가 왜 저 순서대로 나오는지 이해가 되는가?</p><p>waitThreeSeconds() 는 3초가 지나면 실행을 종료한다 ( Execution context 사라짐) -&gt; 한줄한줄 코드를 실행하다 끝에 다다른다 (Global Execution context 사라짐) -&gt; Execution stack 빔 -&gt; 그때서야 event queue 확인 -&gt; 해당 event handler() 실행</p><p>즉, 자바스크립트 엔진은 Execution stack 이 비워지기 전까지 event queue를 처리하지 않다가 <strong>스택이 비게되면(코드를 순차적으로 다 실행하고 나서야) event queue 내에 준비된 event를 처리한다</strong>.</p><p>이것이 자바스크립트가 <strong>동기식으로 비동기식 작업을 처리하는 방식</strong>이다.</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/30/jsw type&amp;operator/">Type &amp; Operator</a></p><p><a href="http://mingguk.github.io/2019/01/29/jsw main/">Main</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jswcc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트를 이해하는데 있어 중요한 기본개념 3가지&lt;/p&gt;
&lt;h3 id=&quot;Syntax-parsers&quot;&gt;&lt;a href=&quot;#Syntax-parsers&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Udemy&gt; Javascript weird parts 시작하기</title>
    <link href="http://mingguk.github.io/2019/01/29/jsw%20main/"/>
    <id>http://mingguk.github.io/2019/01/29/jsw main/</id>
    <published>2019-01-29T02:15:51.000Z</published>
    <updated>2019-01-30T17:29:13.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jswUnderstand.png" alt=""> </p><p>자바스크립트 개념정리를 위해 이러저리 자료를 찾던중 발견한 보석같은 강의 (feat. 연쇄할인마) </p><p>단순 문법이나 기초 예제 복기가 아닌 이면에 자바스크립트가 어떻게 동작하는지 그 원리를(weird parts) 이해하는 것을 목표로 하고 있다. 굳이 왜 작동원리까지..? 라고 생각 할 수 있겠지만 <strong>원리에 대한 이해</strong>를 바탕으로 더 나은 코드를 작성할 수 있다는 주장이다.</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;Hello World&apos;);   //Hello World</span><br></pre></td></tr></table></figure><p>예를들어 Hello world 를 출력하기 위한 이 간단한 코드 이면에, 이를 실행하기 위해 자바스크립트엔진이 어떻게 동작하여 브라우저를 통해 화면에 글자를 출력하게 되는지 같은.. </p><p>사실 codestates pre 과정에서 처음하는 javascript임에도 큰 혼란을 겪지않았던건  먼저 이 강의를 수강하고 간 덕분인것 같다. </p><p><img src="/images/jswLibraries.png" alt=""></p><p>프론트엔드 개발에 흔히 쓰이는 프레임워크, 라이브러리들도 결국 자바스크립트 코드일뿐 이라는 것,                    프론트엔드 개발을 잘하고 싶다, 코드 퀄리티를 높히고 싶다면? 결국 모든것의 기반이 되는 자바스크립트를 깊게 파고 공부하는 것이 최선의 방법</p><p>pre course 공부한 내용이랑 자바스크립트 개념 정리를 위해서 시리즈로 블로그에 정리 포스팅을 연재 할 계획이다 그다음은 오래전 결제하고 조금보다 방치한 <a href="https://www.udemy.com/the-web-developer-bootcamp/" target="_blank" rel="noopener">web bootcamp</a> 랑 <a href="https://www.udemy.com/the-complete-javascript-course/" target="_blank" rel="noopener">javascript real projects</a> 를 완강하고..</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/29/jsw context &amp;ex/">JSW context &amp; scope</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jswUnderstand.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;자바스크립트 개념정리를 위해 이러저리 자료를 찾던중 발견한 보석같은 강의 (feat. 연쇄할인마) &lt;/p&gt;
&lt;p&gt;단순 문법이나 기초 예제 복기가 아닌 
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
      <category term="weirdparts" scheme="http://mingguk.github.io/tags/weirdparts/"/>
    
  </entry>
  
  <entry>
    <title>back</title>
    <link href="http://mingguk.github.io/2019/01/29/back/"/>
    <id>http://mingguk.github.io/2019/01/29/back/</id>
    <published>2019-01-28T16:22:52.000Z</published>
    <updated>2019-01-30T13:51:14.386Z</updated>
    
    <content type="html"><![CDATA[<p>백엔드 카테고리</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;백엔드 카테고리&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Related-Posts&quot;&gt;&lt;a href=&quot;#Related-Posts&quot; class=&quot;headerlink&quot; title=&quot;Related Posts&quot;&gt;&lt;/a&gt;Related Posts&lt;/h3&gt;
      
    
    </summary>
    
      <category term="Back" scheme="http://mingguk.github.io/categories/Back/"/>
    
    
      <category term="back" scheme="http://mingguk.github.io/tags/back/"/>
    
  </entry>
  
  <entry>
    <title>review</title>
    <link href="http://mingguk.github.io/2019/01/29/review/"/>
    <id>http://mingguk.github.io/2019/01/29/review/</id>
    <published>2019-01-28T16:11:57.000Z</published>
    <updated>2019-01-30T13:51:04.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="안녕하세요"><a href="#안녕하세요" class="headerlink" title="안녕하세요"></a>안녕하세요</h3><p>주로 온라인 강의 나 부트캠프로 공부를 많이 해왔기 때문에 (영어 자료 위주)</p><p>필요한 인강의나 강의 선택 시 제 경험이 작은 도움이 됏으면 합니다</p><p>주로 강의를 듣는 사이트</p><ol><li>Udemy </li><li>Udacity</li><li>인프런</li><li>칸아카데미, 코드리뷰</li></ol><hr><h3 id="Related-post"><a href="#Related-post" class="headerlink" title="Related post"></a>Related post</h3><p><a href="http://mingguk.github.io/2019/01/28/codestates/">코드스테이츠 pre course 후기</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;안녕하세요&quot;&gt;&lt;a href=&quot;#안녕하세요&quot; class=&quot;headerlink&quot; title=&quot;안녕하세요&quot;&gt;&lt;/a&gt;안녕하세요&lt;/h3&gt;&lt;p&gt;주로 온라인 강의 나 부트캠프로 공부를 많이 해왔기 때문에 (영어 자료 위주)&lt;/p&gt;
&lt;p&gt;필요한 인강의
      
    
    </summary>
    
      <category term="Review" scheme="http://mingguk.github.io/categories/Review/"/>
    
    
      <category term="review" scheme="http://mingguk.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>코드스테이츠 pre course 후기</title>
    <link href="http://mingguk.github.io/2019/01/28/codestates/"/>
    <id>http://mingguk.github.io/2019/01/28/codestates/</id>
    <published>2019-01-27T21:48:43.000Z</published>
    <updated>2019-01-30T17:38:15.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="아재-비전공-수포자-프로그래밍-도전기"><a href="#아재-비전공-수포자-프로그래밍-도전기" class="headerlink" title="아재, 비전공, 수포자 프로그래밍 도전기"></a>아재, 비전공, 수포자 프로그래밍 도전기</h2><p><img src="/images/nothing.png" alt=""></p><p><strong>3관 타이틀로 과연 개발자가 될 수 있을까?</strong><br>우연히 관심갖게 된 코딩, 온라인강의나 독학을 전전하며 큰 성과없이 있다, 문득 더 늦기 전에 도전해봐야겠다는 생각에 시작한 code states pre course, 시작한지 어느덧 벌써 한달이 지나갔다.<br>지난 한달간 대부분의 시간과 노력을 투자 했음에도 시작 단계라고 만만히 봤던 pre course는 생각보다 훨씬 <strong>‘빡세고’</strong> ,<strong>‘외로운’</strong> 과정이었다</p><h3 id="티칭-이-아니라-‘코칭-’"><a href="#티칭-이-아니라-‘코칭-’" class="headerlink" title="티칭 이 아니라 ‘코칭?’"></a>티칭 이 아니라 ‘코칭?’</h3><p><img src="/images/coaching.jpeg" alt=""></p><p>솔직히 처음엔 코드스테이츠 측에서 딱히 가르쳐 주는 거 없이 너무 날로(?)  하는거 아닌가라는 불만도 있었다 수업이나 강의를 통해 지식을 전달 받고, pair programming 을 통해 거 의견을 공유하면서 같이 코딩을 하는 시간도 있었다 하지만. 대부분은 부여받은 과제를 해결하기 위해 홀로 이리저리 머리를 짜내고 시도하고, 필요한 부분들을 검색해서 다른 방식으로 접근해보는 식의 연속이었다</p><p>시작할때는 뭘 하라는건지 감조차 못잡던 문제들을 직접 부딪혀쳐가며 하나하나 해결해 나가는 과정속에서 나도 모르게 sudo code를 끄적거리고, 내가 생각한 기능을 지원하는 메소드가 있는지 , 이걸 해결하기 위해 내가 모르는게 뭔지, 뭘 공부해야 되는지 검색하고  다시 시도해보는 식의 습관이 자리잡은 것 같다 해결한 과제가 하나 둘 쌓여 갈수록 점점 <strong>코드 스테이츠의 방식에 대한 확신이 강해졌다</strong>  </p><h3 id="결국-문제해결능력"><a href="#결국-문제해결능력" class="headerlink" title="결국 문제해결능력"></a>결국 문제해결능력</h3><p> <img src="/images/ps.jpg" alt=""><br>아직 잘 모르지만, 지인들이나 회사에서 간접적으로 경험했던 개발자들의 모습, 그리고 pre course 를 진행하면서 느낀 것들을 종합해 보자면 결국 개발자의 실력이란 현장에서 직면하는 문제들을 이미 알고 있는 지식으로, 혹은 모르지만 필요한 것들을 빠르게 습득, 적용하여 <strong>효율적으로 문제를 해결하는 것</strong>  아닐까? 한가지 덧붙이자면 상용 어플리케이션의 규모상 혼자가 아닌 <strong>‘함께 문제를 잘 해결 해내는 능력’</strong> 까지  </p><h3 id="‘코칭’-측면에서-codestates-의-가치"><a href="#‘코칭’-측면에서-codestates-의-가치" class="headerlink" title="‘코칭’ 측면에서 codestates 의 가치?"></a>‘코칭’ 측면에서 codestates 의 가치?</h3><p><img src="/images/codestates.png" alt=""></p><p>나는 무엇인가를 배울 때 가장 중요한 것은 <strong>‘내가 뭘 모르는지 정확히 아는것’</strong> 이라고 생각한다 거기서 명확한 계획과 전략이 나오고 노력이 뒷받침 된다면 성공 할 수 있다고 믿는다 비싼 돈 들여 원어민 강사있는 학원에 가도 영어를 유창하게 배울 확률은 매우 낮다 그 원어민 강사들을 당신이 영어의 어떤 부분을 모르고 부족해서 영어가 안되는지 알지 못한다 (혹은 돈이 안되기 때문에 알면서 외면하거나)</p><p><strong>코칭은 대상의 현재 상태와 목표간의 괴리를 객관적으로 파악하고 목표달성을 위한 명확한 방향과 방법을 제시, 서포팅 하는 역할</strong>이다  질의응답이나, pre course 러닝코드 프로그램을 진행하면서 코드스테이츠는 수강생들이 뭘 모르고 어려워하는지, 어떤식으로 도와줘야 되는지 잘 안다는 느낌을 받았다<br>아마 과정을 설계한 엔지니어와 직원들 중 다수가 이전에 codestates 과정들을 이수했기 때문이라고 생각된다</p><p>나 포함 비전공, 생에 첫 코딩, 무관심자들을 진짜 제대로된 개발자로 만들어내기 위해 코드스테이츠가 제시하는 솔루션은  결국 개발자의 본질, <strong>‘문제해결능력’을 키울 수 있도록 잘 유도하는 하는 것</strong> 같다  </p><p>잘 짜여진 시스템과 단계별로 적당히 도전적 난이도로 설계된 과제들로 이끌어 주고, 개발에 집중 할 수 있는 환경조성, 질의응답, 서포트 역할 등..개인적으로 기대 이상 이었고 충분히 만족스러웠다 이러한 강점들은 정해진 가이드라인이 있는 pre course 보다           <strong>각자 프로젝트를 기획, 설계부터 구현까지 스스로 해내야 하는 immersive course</strong> 에서 더   빛을 발하지 않을까 생각된다 </p><p>pre course를 잘 마무리하고 다음 과정인 immersive course 을 통해 제대로 된 개발자로의 커리어 전환에 진지하게 도전해 볼 생각이다</p><p>그동안 주입식, 강의식에 질리고 만족스러운 결과를 얻지 못했다면, 개발을 어떻게 배워야되는지 감을 잡지 못했다면 <strong>codestates</strong> 를 추천하고 싶다<br>물론 <strong>훨씬 고된길</strong>이 되겠지만..</p><h3 id="기타사항들"><a href="#기타사항들" class="headerlink" title="기타사항들"></a>기타사항들</h3><ol><li>학습 환경이 좋다. 성수 패스트파이브 건물 6층 전체, 나머지 층 공유하는거 같은데 오프라인 수강이면 자습환경도 제공한다 (편한자리, 모니터 지원, 5층 카페테리아 공간에서 커피, 음료, <strong>에일맥주</strong> 무료 제공)</li><li>코딩 외에 다른 지원에도 신경 많이 쓰는거 같다 (면접,이력서,협상 등 커리어 관련 / 수강료 부담 관련 we-win제도 / 생활관련 / 학습환경 조성 등 )</li><li>빠른 피드백(온라인 채널)</li><li><del>최애 성수족발이랑 가깝다..</del></li></ol><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="https://www.codestates.com/" target="_blank" rel="noopener">https://www.codestates.com/</a></p><p><a href="https://mingguk.github.io">https://mingguk.github.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;아재-비전공-수포자-프로그래밍-도전기&quot;&gt;&lt;a href=&quot;#아재-비전공-수포자-프로그래밍-도전기&quot; class=&quot;headerlink&quot; title=&quot;아재, 비전공, 수포자 프로그래밍 도전기&quot;&gt;&lt;/a&gt;아재, 비전공, 수포자 프로그래밍 도전기&lt;/
      
    
    </summary>
    
      <category term="Review" scheme="http://mingguk.github.io/categories/Review/"/>
    
      <category term="Bootcamp" scheme="http://mingguk.github.io/categories/Review/Bootcamp/"/>
    
    
      <category term="codestates" scheme="http://mingguk.github.io/tags/codestates/"/>
    
      <category term="코드스테이츠" scheme="http://mingguk.github.io/tags/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%85%8C%EC%9D%B4%EC%B8%A0/"/>
    
  </entry>
  
  <entry>
    <title>third post</title>
    <link href="http://mingguk.github.io/2019/01/28/third-post/"/>
    <id>http://mingguk.github.io/2019/01/28/third-post/</id>
    <published>2019-01-27T21:29:17.000Z</published>
    <updated>2019-01-30T13:49:58.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="html-css-도-해야제"><a href="#html-css-도-해야제" class="headerlink" title="html css 도 해야제"></a>html css 도 해야제</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>카테고리 나누는거 왜케 어렵니..</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;html-css-도-해야제&quot;&gt;&lt;a href=&quot;#html-css-도-해야제&quot; class=&quot;headerlink&quot; title=&quot;html css 도 해야제&quot;&gt;&lt;/a&gt;html css 도 해야제&lt;/h3&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; cla
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="html css" scheme="http://mingguk.github.io/categories/Front/html-css/"/>
    
    
      <category term="html" scheme="http://mingguk.github.io/tags/html/"/>
    
      <category term="css" scheme="http://mingguk.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>first post</title>
    <link href="http://mingguk.github.io/2019/01/28/first-post/"/>
    <id>http://mingguk.github.io/2019/01/28/first-post/</id>
    <published>2019-01-27T21:20:23.000Z</published>
    <updated>2019-01-30T13:49:35.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="처음이라니"><a href="#처음이라니" class="headerlink" title="처음이라니"></a>처음이라니</h3><p>헥소 블로그 세팅 헬..</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/28/second-post/">Javascript 시리즈 2: 자바스크립트 엔진</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;처음이라니&quot;&gt;&lt;a href=&quot;#처음이라니&quot; class=&quot;headerlink&quot; title=&quot;처음이라니&quot;&gt;&lt;/a&gt;처음이라니&lt;/h3&gt;&lt;p&gt;헥소 블로그 세팅 헬..&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Related-Posts&quot;&gt;&lt;a href=&quot;#Re
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>second post</title>
    <link href="http://mingguk.github.io/2019/01/28/second-post/"/>
    <id>http://mingguk.github.io/2019/01/28/second-post/</id>
    <published>2019-01-27T21:20:23.000Z</published>
    <updated>2019-01-30T13:49:46.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="카테고리-나누는게"><a href="#카테고리-나누는게" class="headerlink" title="카테고리 나누는게"></a>카테고리 나누는게</h3><p>이렇게 힘들다니..</p><hr><h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><p><a href="http://mingguk.github.io/2019/01/28/first-post/">Javascript 시리즈 1: 시작하기</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;카테고리-나누는게&quot;&gt;&lt;a href=&quot;#카테고리-나누는게&quot; class=&quot;headerlink&quot; title=&quot;카테고리 나누는게&quot;&gt;&lt;/a&gt;카테고리 나누는게&lt;/h3&gt;&lt;p&gt;이렇게 힘들다니..&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Related-Posts&quot;
      
    
    </summary>
    
      <category term="Front" scheme="http://mingguk.github.io/categories/Front/"/>
    
      <category term="Javascript" scheme="http://mingguk.github.io/categories/Front/Javascript/"/>
    
    
      <category term="javascript" scheme="http://mingguk.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
